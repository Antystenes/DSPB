
==================== FINAL INTERFACE ====================
2017-04-05 00:28:32.516687412 UTC

interface DSPB-0.1.0.0-8DbiYz7G17CFksfrEx0ZXk:Lib 8002
  interface hash: 5337936b9a71ccb25365b75eaebf1dd3
  ABI hash: 10b007d877d217b8b7d3bc89914fad5e
  export-list hash: c439a1552e66549c6716adbb88d14c97
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d114ce8226f534e9d3fcf0d7fc89889a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.appendToLine
  Lib.biggersnd
  Lib.biggersndM
  Lib.changeCent
  Lib.changeMid
  Lib.checkColl
  Lib.compre
  Lib.conwayUpdate
  Lib.countAll
  Lib.counts
  Lib.diffusion
  Lib.dirs
  Lib.emptyNLine
  Lib.fl2dir
  Lib.gridConfigurations
  Lib.height
  Lib.horizNeighb
  Lib.horizontalConfigurations
  Lib.inv
  Lib.limap
  Lib.listPart
  Lib.listPartMol
  Lib.listPartMolD
  Lib.listPartTup
  Lib.lowerNeighb
  Lib.mToList
  Lib.molDir
  Lib.mooresNeighb
  Lib.moveDownGrid
  Lib.moveGrid
  Lib.moveLeftGrid
  Lib.moveLeftLine
  Lib.moveRightGrid
  Lib.moveRightLine
  Lib.moveUpGrid
  Lib.neuConfs
  Lib.neuNeigh
  Lib.nucNeighb
  Lib.nucNeighbN
  Lib.sampleGrid
  Lib.sampleLine
  Lib.sampleNGrid
  Lib.sampleNGrid2
  Lib.sampleNLine
  Lib.simulationGOF
  Lib.simulationN
  Lib.simulationNIO
  Lib.simulationNIO0
  Lib.someFunc
  Lib.updateNuc
  Lib.upperNeighb
  Lib.width
  Lib.Cell{Lib.Alive Lib.Dead}
  Lib.Direction{Lib.Down Lib.Left Lib.Right Lib.Up}
  Lib.Drawable{Lib.draw}
  Lib.Grid{Lib.Grid _down _mid _up}
  Lib.Line{Lib.Line _center _left _right}
  Lib.M2M{Lib.>>=>=}
  Lib.Nucleobase{Lib.A Lib.C Lib.G Lib.U}
  Lib.Nucleotide{Lib.Nucleotide _base _bond3 _bond5 _hbond}
module dependencies:
package dependencies: GLURaw-2.0.0.3@GLURaw-2.0.0.3-G12M6COyQIU5WfRlrIwPuj
                      GLUT-2.7.0.11@GLUT-2.7.0.11-IP0PzJz4wI8KYXyKTnttpl
                      ObjectName-1.1.0.1@ObjectName-1.1.0.1-EiFOWjUQWWuLyOhtrmuIWX
                      OpenGL-3.0.1.0@OpenGL-3.0.1.0-BckrJgI63aX3I0VRJxU6fY
                      OpenGLRaw-3.2.4.0@OpenGLRaw-3.2.4.0-JDyGgOXR61GG549SwmWm2Q
                      StateVar-1.1.0.4@StateVar-1.1.0.4-5dJbnTVECtEAhfJXPZKdbO
                      adjunctions-4.3@adjunctions-4.3-7bX590WM0JqI4H9GMcNEBq
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.5.4@base-orphans-0.5.4-ABoxiBf7nXc7Qqh66CgYc9
                      bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc
                      binary-0.8.3.0@binary-0.8.3.0
                      bmp-1.2.6.3@bmp-1.2.6.3-43OLkH0uuwm831pBFpx2PZ
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      comonad-5@comonad-5-BYydH82fZIS1vK4HJ9v9HH
                      containers-0.5.7.1@containers-0.5.7.1
                      contravariant-1.4@contravariant-1.4-3UCY3arLvoG71jrGOYoc39
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      distributive-0.5.2@distributive-0.5.2-JCgfTXNR3ywAyV7fFWIBI5
                      exceptions-0.8.3@exceptions-0.8.3-ADEDRATtUrMK1JW4zMQ9U
                      fixed-0.2.1.1@fixed-0.2.1.1-8Jr82l0kss5Gr4nEevmXlZ
                      free-4.12.4@free-4.12.4-C89MffdE5zK8lCuYhh5BJR
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz
                      gloss-rendering-1.10.3.5@gloss-rendering-1.10.3.5-4njwxhM0L51DDTj3f5QCty
                      half-0.2.2.3@half-0.2.2.3-GHJ372Ls7FBA3PAGtGHfOR
                      hashable-1.2.6.0@hashable-1.2.6.0-3EXxoqeEgbfAKr6aGkye6x
                      integer-gmp-1.0.0.1
                      kan-extensions-5.0.1@kan-extensions-5.0.1-GfRgigRS3IhJiXd1UYYFjj
                      lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      prelude-extras-0.4.0.3@prelude-extras-0.4.0.3-BhL9U5k7NtGJn1itwIHt2Y
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.1.0@primitive-0.6.1.0-6AbSTw9JXz141LE5p6LGH
                      profunctors-5.2@profunctors-5.2-E83rhkBRsJE8oBXYAZAqjZ
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      reflection-2.1.2@reflection-2.1.2-Bem12O1xFGSHr4C2Hyu1c4
                      semigroupoids-5.1@semigroupoids-5.1-IViIK2AEZZs10fiaW8ySWi
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-IuFogs8HAVUJBWVNMhtssu
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-1XEErQCPPPc2SEtcHHNx9o
                      vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         gloss-rendering-1.10.3.5@gloss-rendering-1.10.3.5-4njwxhM0L51DDTj3f5QCty:Graphics.Gloss.Internals.Data.Picture
         hashable-1.2.6.0@hashable-1.2.6.0-3EXxoqeEgbfAKr6aGkye6x:Data.Hashable.Generic
         reflection-2.1.2@reflection-2.1.2-Bem12O1xFGSHr4C2Hyu1c4:Data.Reflection
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Unboxed
family instance modules: adjunctions-4.3@adjunctions-4.3-7bX590WM0JqI4H9GMcNEBq:Data.Functor.Rep
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Biff
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Clown
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Flip
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Join
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Joker
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Product
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Sum
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Tannen
                         bifunctors-5.4.1@bifunctors-5.4.1-LZeQTL0Uaws6v2aJY5STuc:Data.Bifunctor.Wrapped
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         kan-extensions-5.0.1@kan-extensions-5.0.1-GfRgigRS3IhJiXd1UYYFjj:Data.Functor.Day
                         kan-extensions-5.0.1@kan-extensions-5.0.1-GfRgigRS3IhJiXd1UYYFjj:Data.Functor.Yoneda
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.At
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.Internal.Indexed
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.Reified
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.Tuple
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.Wrapped
                         lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens.Zoom
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primitive-0.6.1.0-6AbSTw9JXz141LE5p6LGH:Control.Monad.Primitive
                         profunctors-5.2@profunctors-5.2-E83rhkBRsJE8oBXYAZAqjZ:Data.Profunctor.Rep
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-1XEErQCPPPc2SEtcHHNx9o:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-1XEErQCPPPc2SEtcHHNx9o:Data.HashSet
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Primitive
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Storable
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Unboxed
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Unboxed.Base
import  -/  base-4.9.1.0:Control.Arrow 70754b538e7d75521cd68162917b6946
import  -/  base-4.9.1.0:Control.Category 74288f70105bf6db5ff51d18c3e2c349
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Function 7aca86bfbd92366def5f260e30cb2628
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:Debug.Trace a9edf3aec504f4423d8ba829ab373a25
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  comonad-5@comonad-5-BYydH82fZIS1vK4HJ9v9HH:Control.Comonad 78c4a5a8d1fa2773796a85c577c3c580
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss 446fba84c72c2162e0e53dbea5b10a12
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss.Data.Color 35f09dcf5824a501e40cfcf03326b2bc
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss.Data.Display 5392242cf7ec93ea58fa9cb1cc259a3f
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss.Data.Picture 32f91608a8bdee9c0064dc93458da74d
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss.Interface.IO.Simulate beac7490689c00fd65581d4b9b935bed
import  -/  gloss-1.10.2.5@gloss-1.10.2.5-Cjq2LIsB60XBDXiLGr6ISz:Graphics.Gloss.Interface.Pure.Simulate 7d85c20229e42520b9adab85f50d5f7a
import  -/  gloss-rendering-1.10.3.5@gloss-rendering-1.10.3.5-4njwxhM0L51DDTj3f5QCty:Graphics.Gloss.Internals.Data.Picture ec8d0a362f39091fe9e13deed4330688
import  -/  lens-4.15.1@lens-4.15.1-2bPnjHpJoHy2zLogJCwNGD:Control.Lens 119ffa0654492e3f1025b64be63262f4
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random 08e50ea8c400b4b56120dee22f012f01
97e610ce435ee1b9acdb866559c18234
  $fComonadGrid :: Control.Comonad.Comonad Lib.Grid
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Grid
                  Lib.$fFunctorGrid
                  Lib.$fComonadGrid_$cextract
                  Lib.gridConfigurations
                  Lib.$fComonadGrid_$cextend -}
97e610ce435ee1b9acdb866559c18234
  $fComonadGrid_$cextend ::
    (Lib.Grid a -> b) -> Lib.Grid a -> Lib.Grid b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S,1*U(U,U(U,U,U),U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: Lib.Grid a -> b) (x2 :: Lib.Grid a) ->
                 Lib.$fComonadGrid_$cfmap
                   @ (Lib.Grid a)
                   @ b
                   eta
                   (Lib.gridConfigurations @ a x2)) -}
97e610ce435ee1b9acdb866559c18234
  $fComonadGrid_$cextract :: Lib.Grid a -> a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),1*U(A,1*U(A,1*U,A),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 ds2 ds3 ->
                 case ds2 of wild1 { Lib.Line ds4 x2 ds5 -> x2 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fComonadGrid_$cfmap :: (a -> b) -> Lib.Grid a -> Lib.Grid b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.Grid
                   @ b
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line b)
                      (Lib.$fComonadGrid_$cfmap1 @ a @ b w)
                      ww1)
                   (Lib.$fComonadGrid_$cfmap1 @ a @ b w ww2)
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line b)
                      (Lib.$fComonadGrid_$cfmap1 @ a @ b w)
                      ww3) }) -}
2f4df898c4c0464346eb0a501aa024be
  $fComonadGrid_$cfmap1 :: (a -> b) -> Lib.Line a -> Lib.Line b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.Line
                   @ b
                   (GHC.Base.map @ a @ b w ww1)
                   (w ww2)
                   (GHC.Base.map @ a @ b w ww3) }) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableCell :: Lib.Drawable Lib.Cell
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Lib.$fDrawableCell_$cdraw
                  `cast`
                (Sym (Lib.N:Drawable[0] <Lib.Cell>_N)) -}
8f1d5c6d59a1a97956a925cdf1b1c4cc
  $fDrawableCell1 :: Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m14,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Pictures
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture)) -}
9e148b9090f225f4266c8291b3dde145
  $fDrawableCell2 :: Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m10,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Color
                   Graphics.Gloss.Data.Color.blue
                   Lib.$fDrawableCell3) -}
55b1c66fb5deaa3243221daf4534ea9f
  $fDrawableCell3 :: Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.ThickCircle
                   Lib.$fDrawableCell4
                   Lib.$fDrawableCell_r) -}
53e5203246b32b694c13560268b19192
  $fDrawableCell4 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 2.5#) -}
708bae4ffd2d4a7db362b285417d8652
  $fDrawableCell_$cdraw ::
    Lib.Cell -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Alive -> Lib.$fDrawableCell2
                   Lib.Dead -> Lib.$fDrawableCell1 }) -}
d0bddb696f6d683bd5138d364c9bfe67
  $fDrawableCell_r :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 5.0#) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableGrid :: Lib.Drawable a => Lib.Drawable (Lib.Grid a)
  DFunId
  {- Arity: 2,
     Strictness: <L,C(U)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>m14,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Lib.$fDrawableGrid_$cdraw
                  `cast`
                (forall (a :: <*>_N).
                 <Lib.Drawable a>_R ->_R Sym (Lib.N:Drawable[0] <Lib.Grid a>_N)) -}
5e875cb3a7cc935ece13504926b22ae7
  $fDrawableGrid1 :: [GHC.Types.Float]
  {- Unfolding: (case GHC.Real.$wnumericEnumFromThen
                        @ GHC.Types.Float
                        GHC.Float.$fFractionalFloat
                        Lib.$fDrawableGrid3
                        Lib.$fDrawableGrid2 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Float ww1 ww2 }) -}
7cecc2c5b5410c7c8e8634a127c29ef1
  $fDrawableGrid2 :: GHC.Types.Float
  {- HasNoCafRefs, Unfolding: (GHC.Types.F# 20.0#) -}
c94287d70e09bd88db1d530e04d8047f
  $fDrawableGrid3 :: GHC.Types.Float
  {- HasNoCafRefs, Unfolding: (GHC.Types.F# 10.0#) -}
0b67a4f722361de4101cf6fb213035c2
  $fDrawableGrid4 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 0.0#) -}
48b276845ce788548c9034f987eacd8c
  $fDrawableGrid5 :: [GHC.Types.Float]
  {- Unfolding: (case GHC.Real.$wnumericEnumFromThen
                        @ GHC.Types.Float
                        GHC.Float.$fFractionalFloat
                        Lib.$fDrawableGrid7
                        Lib.$fDrawableGrid6 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Float ww1 ww2 }) -}
0c31570e752b77d3c73e08a81080f694
  $fDrawableGrid6 :: GHC.Types.Float
  {- HasNoCafRefs, Unfolding: (GHC.Types.F# -20.0#) -}
bd57732ef4876a6fac1a83b401001a78
  $fDrawableGrid7 :: GHC.Types.Float
  {- HasNoCafRefs, Unfolding: (GHC.Types.F# -10.0#) -}
045513a268cdbbb26d86555a4f0a92e7
  $fDrawableGrid8 ::
    GHC.Types.Float
    -> Graphics.Gloss.Internals.Data.Picture.Picture
    -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Translate
                   Lib.$fDrawableGrid4) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableGrid_$cdraw ::
    Lib.Drawable a =>
    Lib.Grid a -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 2,
     Strictness: <L,C(U)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>m14,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lib.Drawable a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case Lib.$w$cdraw @ a w ww1 ww2 ww3 of ww4 { Unit# ww5 ->
                 Graphics.Gloss.Internals.Data.Picture.Pictures ww5 } }) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableGrid_$cdraw1 ::
    Lib.Drawable a =>
    Lib.Line a -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 2, Strictness: <L,C(U)><S,1*U(1*U,U,1*U)>m14,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lib.Drawable a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 case Lib.$w$cdraw1 @ a w ww1 ww2 ww3 of ww4 { Unit# ww5 ->
                 Graphics.Gloss.Internals.Data.Picture.Pictures ww5 } }) -}
77f1a3bf18057f3e663f589bdef9eba6
  $fDrawableGrid_update ::
    GHC.Types.Float
    -> Graphics.Gloss.Internals.Data.Picture.Picture
    -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Types.Float)
                   (ds1 :: Graphics.Gloss.Internals.Data.Picture.Picture) ->
                 case ds1 of wild {
                   DEFAULT
                   -> Graphics.Gloss.Internals.Data.Picture.Translate
                        ds
                        Lib.$fDrawableGrid4
                        wild
                   Graphics.Gloss.Internals.Data.Picture.Pictures ds2
                   -> case ds2 of wild1 {
                        [] -> Lib.$fDrawableCell1
                        : ipv ipv1
                        -> Graphics.Gloss.Internals.Data.Picture.Translate
                             ds
                             Lib.$fDrawableGrid4
                             wild } }) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableLine :: Lib.Drawable a => Lib.Drawable (Lib.Line a)
  DFunId
  {- Arity: 2, Strictness: <L,C(U)><S,1*U(1*U,U,1*U)>m14,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Lib.$fDrawableGrid_$cdraw1
                  `cast`
                (forall (a :: <*>_N).
                 <Lib.Drawable a>_R ->_R Sym (Lib.N:Drawable[0] <Lib.Line a>_N)) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableMaybe ::
    Lib.Drawable a => Lib.Drawable (GHC.Base.Maybe a)
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Lib.$fDrawableMaybe_$cdraw
                  `cast`
                (forall (a :: <*>_N).
                 <Lib.Drawable a>_R
                 ->_R Sym (Lib.N:Drawable[0] <GHC.Base.Maybe a>_N)) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableMaybe_$cdraw ::
    Lib.Drawable a =>
    GHC.Base.Maybe a -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dDrawable :: Lib.Drawable a) (ds :: GHC.Base.Maybe a) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Lib.$fDrawableCell1
                   GHC.Base.Just n
                   -> $dDrawable `cast` (Lib.N:Drawable[0] <a>_N) n }) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableNucleobase :: Lib.Drawable Lib.Nucleobase
  DFunId
  {- Arity: 1, Strictness: <L,1*U>m10, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Lib.$fDrawableNucleobase_$cdraw
                  `cast`
                (Sym (Lib.N:Drawable[0] <Lib.Nucleobase>_N)) -}
723b91993c9252d0687970971f1f4457
  $fDrawableNucleobase1 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.ThickCircle
                   Lib.$fDrawableNucleobase2
                   Lib.$fDrawableNucleobase_r) -}
cc91873440d645ebbe684678beb56615
  $fDrawableNucleobase2 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 2.0#) -}
a0e16f35c30af25752af79415e784be0
  $fDrawableNucleobase_$cdraw ::
    Lib.Nucleobase -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 1, Strictness: <L,1*U>m10,
     Unfolding: InlineRule (1, True, False)
                (\ (g :: Lib.Nucleobase) ->
                 Graphics.Gloss.Internals.Data.Picture.Color
                   (case g of wild {
                      Lib.A -> Graphics.Gloss.Data.Color.blue
                      Lib.U -> Graphics.Gloss.Data.Color.red
                      Lib.G -> Graphics.Gloss.Data.Color.green
                      Lib.C -> Graphics.Gloss.Data.Color.yellow })
                   Lib.$fDrawableNucleobase1) -}
560b39deb2a34289a5d59c0f33c0560b
  $fDrawableNucleobase_r :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 4.0#) -}
6db36b4d38b28348552cbd2d9f84f364
  $fDrawableNucleotide :: Lib.Drawable Lib.Nucleotide
  DFunId
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,A)>m14,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Lib.$fDrawableNucleotide_$cdraw
                  `cast`
                (Sym (Lib.N:Drawable[0] <Lib.Nucleotide>_N)) -}
214b93b1dc3aa30b222f621c32f86e3c
  $fDrawableNucleotide1 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- Strictness: m10,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Color
                   Graphics.Gloss.Data.Color.violet
                   Lib.$fDrawableNucleotide2) -}
7fb337f4402271b1987a024695642acf
  $fDrawableNucleotide10 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide11
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Point)) -}
3d298edd4b5b3126c2b73b6ce9f5c2ea
  $fDrawableNucleotide11 :: (GHC.Types.Float, GHC.Types.Float)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.$fDrawableNucleotide12, Lib.$fDrawableGrid4)) -}
a591d05e7e9315b48d32702f58c793f7
  $fDrawableNucleotide12 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# -5.0#) -}
8343dd08084addad16616b27e3f0599f
  $fDrawableNucleotide13 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- Strictness: m10,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Color
                   Graphics.Gloss.Data.Color.violet
                   Lib.$fDrawableNucleotide14) -}
cd9c3310bbfb0a239830395c7313af0f
  $fDrawableNucleotide14 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Line
                   Lib.$fDrawableNucleotide15) -}
adbf5a416f05d7c063217b9f1f781a91
  $fDrawableNucleotide15 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide6
                   Lib.$fDrawableNucleotide16) -}
3cb2781926961138356b9267dcba35a9
  $fDrawableNucleotide16 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide17
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Point)) -}
d95706aa862ae2663a77998c80591bbf
  $fDrawableNucleotide17 :: (GHC.Types.Float, GHC.Types.Float)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.$fDrawableGrid4, Lib.$fDrawableNucleotide12)) -}
7ad52724a2048c7252a66c53de10d4c0
  $fDrawableNucleotide18 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- Strictness: m10,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Color
                   Graphics.Gloss.Data.Color.violet
                   Lib.$fDrawableNucleotide19) -}
76e1847c12758db91994697e93e8f2b8
  $fDrawableNucleotide19 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Line
                   Lib.$fDrawableNucleotide20) -}
184c879eaab258dd77af774464ec5551
  $fDrawableNucleotide2 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Line
                   Lib.$fDrawableNucleotide3) -}
ac2f60177b7a5e048f952a228a818ff7
  $fDrawableNucleotide20 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide6
                   Lib.$fDrawableNucleotide21) -}
e10fa6eae94f1cac6f6f477ab36503ed
  $fDrawableNucleotide21 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide22
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Point)) -}
8992b37bccf76d971bf31a6c0d660682
  $fDrawableNucleotide22 :: (GHC.Types.Float, GHC.Types.Float)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.$fDrawableGrid4, Lib.$fDrawableCell_r)) -}
2be920061c026fdcaa1be45e462a2b11
  $fDrawableNucleotide23 ::
    [Graphics.Gloss.Internals.Data.Picture.Picture]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                   Lib.$fDrawableNucleotide2
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture)) -}
95ea5c60245ab046c1be4cd4b8ba45cc
  $fDrawableNucleotide24 ::
    [Graphics.Gloss.Internals.Data.Picture.Picture]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                   Lib.$fDrawableNucleotide8
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture)) -}
6e55a1511ac47dbf1622237fc7238b67
  $fDrawableNucleotide25 ::
    [Graphics.Gloss.Internals.Data.Picture.Picture]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                   Lib.$fDrawableNucleotide14
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture)) -}
32e21b263722a4c71f390de883eee2a7
  $fDrawableNucleotide26 ::
    [Graphics.Gloss.Internals.Data.Picture.Picture]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                   Lib.$fDrawableNucleotide19
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture)) -}
735de4f5b529351f85747a68c6fa8f0c
  $fDrawableNucleotide3 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide6
                   Lib.$fDrawableNucleotide4) -}
e10cf29d02cd48f29e821082e2575b5e
  $fDrawableNucleotide4 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide5
                   (GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Point)) -}
02b6c228e28c0ba73aef3b4d8a908b81
  $fDrawableNucleotide5 :: (GHC.Types.Float, GHC.Types.Float)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.$fDrawableCell_r, Lib.$fDrawableGrid4)) -}
8b48f5368f2d5249ebb100b4af870436
  $fDrawableNucleotide6 :: (GHC.Types.Float, GHC.Types.Float)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.$fDrawableGrid4, Lib.$fDrawableGrid4)) -}
0c8a21018ea19804f258ba5f6455bf1d
  $fDrawableNucleotide7 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- Strictness: m10,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Color
                   Graphics.Gloss.Data.Color.violet
                   Lib.$fDrawableNucleotide8) -}
4d40a5c9b8c0593197111c3cb017d940
  $fDrawableNucleotide8 ::
    Graphics.Gloss.Internals.Data.Picture.Picture
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Graphics.Gloss.Internals.Data.Picture.Line
                   Lib.$fDrawableNucleotide9) -}
c410674d998ea64a28761135406b72d9
  $fDrawableNucleotide9 ::
    [Graphics.Gloss.Internals.Data.Picture.Point]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Graphics.Gloss.Internals.Data.Picture.Point
                   Lib.$fDrawableNucleotide6
                   Lib.$fDrawableNucleotide10) -}
fd567e030a6d757640fb85ec12e1f4a7
  $fDrawableNucleotide_$cdraw ::
    Lib.Nucleotide -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,A)>m14,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Nucleotide) ->
                 case Lib.$w$cdraw2 w of ww { Unit# ww1 ->
                 Graphics.Gloss.Internals.Data.Picture.Pictures ww1 }) -}
38face69c74bc9252fe607ee7c2ba36c
  $fEqCell :: GHC.Classes.Eq Lib.Cell
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Cell Lib.$fEqCell_$c== Lib.$fEqCell_$c/= -}
38face69c74bc9252fe607ee7c2ba36c
  $fEqCell_$c/= :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Lib.Cell) (b :: Lib.Cell) ->
                 case a of wild {
                   Lib.Alive
                   -> case b of wild1 {
                        Lib.Alive -> GHC.Types.False Lib.Dead -> GHC.Types.True }
                   Lib.Dead
                   -> case b of wild1 {
                        Lib.Alive -> GHC.Types.True Lib.Dead -> GHC.Types.False } }) -}
38face69c74bc9252fe607ee7c2ba36c
  $fEqCell_$c== :: Lib.Cell -> Lib.Cell -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Lib.Cell) (ds1 :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Alive
                   -> case ds1 of wild1 {
                        Lib.Alive -> GHC.Types.True Lib.Dead -> GHC.Types.False }
                   Lib.Dead
                   -> case ds1 of wild1 {
                        Lib.Alive -> GHC.Types.False Lib.Dead -> GHC.Types.True } }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fEqDirection :: GHC.Classes.Eq Lib.Direction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Direction Lib.$fEqDirection_$c== Lib.$fEqDirection_$c/= -}
849e8452416a49d9a7ee131cfd2b5f90
  $fEqDirection_$c/= ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Direction) (b :: Lib.Direction) ->
                 case a of wild {
                   Lib.Up
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.Up -> GHC.Types.False }
                   Lib.Down
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.Down -> GHC.Types.False }
                   Lib.Left
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.Left -> GHC.Types.False }
                   Lib.Right
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.Right -> GHC.Types.False } }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fEqDirection_$c== ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lib.Direction) (ds1 :: Lib.Direction) ->
                 case ds of wild {
                   Lib.Up
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.Up -> GHC.Types.True }
                   Lib.Down
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.Down -> GHC.Types.True }
                   Lib.Left
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.Left -> GHC.Types.True }
                   Lib.Right
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.Right -> GHC.Types.True } }) -}
97e610ce435ee1b9acdb866559c18234
  $fEqGrid :: GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Grid a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Lib.Grid a)
                  (Lib.$fEqGrid_$c== @ a $dEq)
                  (Lib.$fEqGrid_$c/= @ a $dEq) -}
55db2c86956d0ee80e62e43859ef596f
  $fEqGrid1 :: GHC.Classes.Eq (Lib.Nucleotide, Lib.Direction)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Lib.$fEqGrid_$s$fEq(,) -}
589c6c6ea223598c51d9c3933ab1deeb
  $fEqGrid2 ::
    GHC.Classes.Eq
      (Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
  {- Unfolding: (Lib.$fEqLine
                   @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   Lib.$fEqGrid_$s$fEqMaybe) -}
97e610ce435ee1b9acdb866559c18234
  $fEqGrid_$c/= ::
    GHC.Classes.Eq a => Lib.Grid a -> Lib.Grid a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Lib.Grid a)
                   (b :: Lib.Grid a) ->
                 case Lib.$fEqGrid_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
97e610ce435ee1b9acdb866559c18234
  $fEqGrid_$c== ::
    GHC.Classes.Eq a => Lib.Grid a -> Lib.Grid a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Lib.Line a) = Lib.$fEqLine @ a $dEq
                 } in
                 \ (ds :: Lib.Grid a) (ds1 :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid a1 a2 a3 ->
                 case ds1 of wild1 { Lib.Grid b1 b2 b3 ->
                 case GHC.Classes.$fEq[]_$c== @ (Lib.Line a) $dEq1 a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case a2 of ww { Lib.Line ww1 ww2 ww3 ->
                      case b2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                      case GHC.Classes.$fEq[]_$c== @ a $dEq ww1 ww5 of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.== @ a $dEq ww2 ww6 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c== @ a $dEq ww3 ww7 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEq[]_$c==
                                       @ (Lib.Line a)
                                       $dEq1
                                       a3
                                       b3 } } } } } } } }) -}
febe209ebc4f26ed6d5f7824e029b38a
  $fEqGrid_$s$fEq(,) ::
    GHC.Classes.Eq (Lib.Nucleotide, Lib.Direction)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Nucleotide, Lib.Direction)
                  (GHC.Classes.$fEq(,)_$c==
                     @ Lib.Nucleotide
                     @ Lib.Direction
                     Lib.$fEqNucleotide
                     Lib.$fEqDirection)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ Lib.Nucleotide
                     @ Lib.Direction
                     Lib.$fEqNucleotide
                     Lib.$fEqDirection) -}
f992231cd309876cdaefb8a1883dc703
  $fEqGrid_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                  Lib.$fEqGrid_$s$fEqMaybe_$c==
                  (GHC.Base.$fEqMaybe_$c/=
                     @ (Lib.Nucleotide, Lib.Direction)
                     Lib.$fEqGrid1) -}
ac6393659575f27ce6b4867d0433cf68
  $fEqGrid_$s$fEqMaybe_$c== ::
    GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   (ds1 :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> GHC.Classes.$fEq(,)_$c==
                             @ Lib.Nucleotide
                             @ Lib.Direction
                             Lib.$fEqNucleotide
                             Lib.$fEqDirection
                             a1
                             b1 } }) -}
2f4df898c4c0464346eb0a501aa024be
  $fEqLine :: GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Line a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Lib.Line a)
                  (Lib.$fEqLine_$c== @ a $dEq)
                  (Lib.$fEqLine_$c/= @ a $dEq) -}
2f4df898c4c0464346eb0a501aa024be
  $fEqLine_$c/= ::
    GHC.Classes.Eq a => Lib.Line a -> Lib.Line a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SLL),1*U(1*U,U,1*U)><S(SLL),1*U(1*U,U,1*U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Lib.Line a)
                   (b :: Lib.Line a) ->
                 case Lib.$fEqLine_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2f4df898c4c0464346eb0a501aa024be
  $fEqLine_$c== ::
    GHC.Classes.Eq a => Lib.Line a -> Lib.Line a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SLL),1*U(1*U,U,1*U)><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Lib.Line a)
                   (w2 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 case w2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$c==1 @ a w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
6b4115b92802191b7bdce7a8072a082e
  $fEqNucleobase :: GHC.Classes.Eq Lib.Nucleobase
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Nucleobase Lib.$fEqNucleobase_$c== Lib.$fEqNucleobase_$c/= -}
6b4115b92802191b7bdce7a8072a082e
  $fEqNucleobase_$c/= ::
    Lib.Nucleobase -> Lib.Nucleobase -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lib.Nucleobase) (b :: Lib.Nucleobase) ->
                 case a of wild {
                   Lib.A
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.A -> GHC.Types.False }
                   Lib.U
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.U -> GHC.Types.False }
                   Lib.G
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.G -> GHC.Types.False }
                   Lib.C
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Lib.C -> GHC.Types.False } }) -}
6b4115b92802191b7bdce7a8072a082e
  $fEqNucleobase_$c== ::
    Lib.Nucleobase -> Lib.Nucleobase -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lib.Nucleobase) (ds1 :: Lib.Nucleobase) ->
                 case ds of wild {
                   Lib.A
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.A -> GHC.Types.True }
                   Lib.U
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.U -> GHC.Types.True }
                   Lib.G
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.G -> GHC.Types.True }
                   Lib.C
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.C -> GHC.Types.True } }) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fEqNucleotide :: GHC.Classes.Eq Lib.Nucleotide
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Nucleotide Lib.$fEqNucleotide_$c== Lib.$fEqNucleotide_$c/= -}
a507435bbb1291d2b58fe6be4899ccaa
  $fEqNucleotide_$c/= ::
    Lib.Nucleotide -> Lib.Nucleotide -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Lib.Nucleotide) (b :: Lib.Nucleotide) ->
                 case Lib.$fEqNucleotide_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fEqNucleotide_$c== ::
    Lib.Nucleotide -> Lib.Nucleotide -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Nucleotide) (w1 :: Lib.Nucleotide) ->
                 case w of ww { Lib.Nucleotide ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { Lib.Nucleotide ww6 ww7 ww8 ww9 ->
                 Lib.$w$c== ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid :: Data.Foldable.Foldable Lib.Grid
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Grid
                  Lib.$fFoldableGrid_$cfold
                  Lib.$fFoldableGrid_$cfoldMap
                  Lib.$fFoldableGrid_$cfoldr
                  Lib.$fFoldableGrid_$cfoldr'
                  Lib.$fFoldableGrid_$cfoldl
                  Lib.$fFoldableGrid_$cfoldl'
                  Lib.$fFoldableGrid_$cfoldr1
                  Lib.$fFoldableGrid_$cfoldl1
                  Lib.$fFoldableGrid_$ctoList
                  Lib.$fFoldableGrid_$cnull
                  Lib.$fFoldableGrid_$clength
                  Lib.$fFoldableGrid_$celem
                  Lib.$fFoldableGrid_$cmaximum
                  Lib.$fFoldableGrid_$cminimum
                  Lib.$fFoldableGrid_$csum
                  Lib.$fFoldableGrid_$cproduct -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid1 ::
    GHC.Num.Num a => Lib.Grid a -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cproduct @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid2 :: GHC.Num.Num a => Lib.Grid a -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$csum @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
b1f5d4afd1a702fe51e4f199c6c82bf0
  $fFoldableGrid3 :: a
  {- Strictness: x -}
a018f3247a26b186f1d6447e72ede81a
  $fFoldableGrid4 :: a
  {- Strictness: x -}
be35a4797437a9f19567385da5cad1f3
  $fFoldableGrid5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
4c1bcf4c459e69a455c59688b465c3c4
  $fFoldableGrid6 ::
    a
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a
                   (x2 :: a)
                   (k :: GHC.Types.Int -> GHC.Types.Int)[OneShot]
                   (z :: GHC.Types.Int) ->
                 case z of wild { GHC.Types.I# x3 ->
                 k (GHC.Types.I# (GHC.Prim.+# x3 1#)) }) -}
326e546399f1466bc7287109c5347ed9
  $fFoldableGrid7 :: a -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (ds :: a) (ds1 :: GHC.Types.Bool) -> GHC.Types.False) -}
e562cd89e29ea7679b84823ada396d53
  $fFoldableGrid8 :: a
  {- Strictness: x -}
d0d63972b83201d3e69832e9d05843c3
  $fFoldableGrid9 :: a
  {- Strictness: x -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$celem ::
    GHC.Classes.Eq a => a -> Lib.Grid a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 let {
                   lvl31 :: a -> GHC.Types.Bool -> GHC.Types.Bool {- Arity: 2 -}
                   = \ (x2 :: a) (ds1 :: GHC.Types.Bool)[OneShot] ->
                     case f x2 of wild {
                       GHC.Types.False -> ds1 GHC.Types.True -> GHC.Types.True }
                 } in
                 (\ (eta1 :: Lib.Grid a) ->
                  case eta1 of ww { Lib.Grid ww1 ww2 ww3 ->
                  case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                  Lib.$w$cfoldr
                    @ a
                    @ Data.Monoid.Any
                    lvl31
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Any[0])
                     ->_R Sym (Data.Monoid.N:Any[0]))
                    GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                    ww1
                    ww5
                    ww6
                    ww7
                    ww3 } })
                   `cast`
                 (<Lib.Grid a>_R ->_R Data.Monoid.N:Any[0])) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfold :: GHC.Base.Monoid m => Lib.Grid m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSL),U(1*U,1*U,A)><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ m (w :: GHC.Base.Monoid m) (w1 :: Lib.Grid m) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfold @ m w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Lib.Grid a -> m
  {- Arity: 2, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: Lib.Grid a) ->
                 let {
                   f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                 } in
                 Lib.$fFoldableGrid_$cfoldr
                   @ a
                   @ m
                   (\ (x2 :: a) -> f1 (f x2))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldl :: (b -> a -> b) -> b -> Lib.Grid a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (w :: b -> a -> b) (w1 :: b) (w2 :: Lib.Grid a) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldl @ b @ a w w1 ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldl' :: (b -> a -> b) -> b -> Lib.Grid a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (w :: b -> a -> b) (w1 :: b) (w2 :: Lib.Grid a) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldl' @ b @ a w w1 ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldl1 :: (a -> a -> a) -> Lib.Grid a -> a
  {- Arity: 2,
     Strictness: <L,C(C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldl1 @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldr :: (a -> b -> b) -> b -> Lib.Grid a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (w :: a -> b -> b) (w1 :: b) (w2 :: Lib.Grid a) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldr @ a @ b w w1 ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldr' :: (a -> b -> b) -> b -> Lib.Grid a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (w :: a -> b -> b) (w1 :: b) (w2 :: Lib.Grid a) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldr' @ a @ b w w1 ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cfoldr1 :: (a -> a -> a) -> Lib.Grid a -> a
  {- Arity: 2,
     Strictness: <L,C(C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldr2 @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$clength :: Lib.Grid a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$clength @ a ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cmaximum :: GHC.Classes.Ord a => Lib.Grid a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cmaximum @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cminimum :: GHC.Classes.Ord a => Lib.Grid a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cminimum @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cnull :: Lib.Grid a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$w$cfoldr
                   @ a
                   @ GHC.Types.Bool
                   (Lib.$fFoldableGrid7 @ a)
                   GHC.Types.True
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$cproduct :: GHC.Num.Num a => Lib.Grid a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fFoldableGrid1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Lib.Grid a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$csum :: GHC.Num.Num a => Lib.Grid a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S(SS(SLL)L),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fFoldableGrid2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Lib.Grid a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
97e610ce435ee1b9acdb866559c18234
  $fFoldableGrid_$ctoList :: Lib.Grid a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Lib.Grid a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Lib.$fFoldableGrid_$cfoldr @ a @ b c n t1)) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine :: Data.Foldable.Foldable Lib.Line
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Line
                  Lib.$fFoldableLine_$cfold
                  Lib.$fFoldableLine_$cfoldMap
                  Lib.$fFoldableLine_$cfoldr
                  Lib.$fFoldableLine_$cfoldr'
                  Lib.$fFoldableLine_$cfoldl
                  Lib.$fFoldableLine_$cfoldl'
                  Lib.$fFoldableLine_$cfoldr1
                  Lib.$fFoldableLine_$cfoldl1
                  Lib.$fFoldableLine_$ctoList
                  Lib.$fFoldableLine_$cnull
                  Lib.$fFoldableLine_$clength
                  Lib.$fFoldableLine_$celem
                  Lib.$fFoldableLine_$cmaximum
                  Lib.$fFoldableLine_$cminimum
                  Lib.$fFoldableLine_$csum
                  Lib.$fFoldableLine_$cproduct -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine1 ::
    GHC.Num.Num a => Lib.Line a -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cproduct1 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine2 :: GHC.Num.Num a => Lib.Line a -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$csum1 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$celem ::
    GHC.Classes.Eq a => a -> Lib.Line a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 let {
                   lvl31 :: a -> GHC.Types.Bool -> GHC.Types.Bool {- Arity: 2 -}
                   = \ (x2 :: a) (ds1 :: GHC.Types.Bool)[OneShot] ->
                     case f x2 of wild {
                       GHC.Types.False -> ds1 GHC.Types.True -> GHC.Types.True }
                 } in
                 (\ (eta1 :: Lib.Line a) ->
                  case eta1 of ww { Lib.Line ww1 ww2 ww3 ->
                  Lib.$w$cfoldr1
                    @ a
                    @ Data.Monoid.Any
                    lvl31
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Any[0])
                     ->_R Sym (Data.Monoid.N:Any[0]))
                    GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                    ww1
                    ww2
                    ww3 })
                   `cast`
                 (<Lib.Line a>_R ->_R Data.Monoid.N:Any[0])) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfold :: GHC.Base.Monoid m => Lib.Line m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSL),U(1*U,1*U,A)><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ m (w :: GHC.Base.Monoid m) (w1 :: Lib.Line m) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfold1 @ m w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Lib.Line a -> m
  {- Arity: 2, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: Lib.Line a) ->
                 let {
                   f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                 } in
                 Lib.$fFoldableLine_$cfoldr
                   @ a
                   @ m
                   (\ (x2 :: a) -> f1 (f x2))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldl :: (b -> a -> b) -> b -> Lib.Line a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (w :: b -> a -> b) (w1 :: b) (w2 :: Lib.Line a) ->
                 case w2 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldl3 @ b @ a w w1 ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldl' :: (b -> a -> b) -> b -> Lib.Line a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (w :: b -> a -> b) (w1 :: b) (w2 :: Lib.Line a) ->
                 case w2 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldl'1 @ b @ a w w1 ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldl1 :: (a -> a -> a) -> Lib.Line a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldl2 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldr :: (a -> b -> b) -> b -> Lib.Line a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (w :: a -> b -> b) (w1 :: b) (w2 :: Lib.Line a) ->
                 case w2 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldr1 @ a @ b w w1 ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldr' :: (a -> b -> b) -> b -> Lib.Line a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (w :: a -> b -> b) (w1 :: b) (w2 :: Lib.Line a) ->
                 case w2 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldr'1 @ a @ b w w1 ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cfoldr1 :: (a -> a -> a) -> Lib.Line a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldr3 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$clength :: Lib.Line a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Line a) ->
                 case w of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$clength1 @ a ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cmaximum :: GHC.Classes.Ord a => Lib.Line a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cmaximum1 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cminimum :: GHC.Classes.Ord a => Lib.Line a -> a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cminimum1 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cnull :: Lib.Line a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a (w :: Lib.Line a) ->
                 case w of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cfoldr1
                   @ a
                   @ GHC.Types.Bool
                   (Lib.$fFoldableGrid7 @ a)
                   GHC.Types.True
                   ww1
                   ww2
                   ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$cproduct :: GHC.Num.Num a => Lib.Line a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fFoldableLine1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Lib.Line a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$csum :: GHC.Num.Num a => Lib.Line a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S(SLL),1*U(1*U,U,1*U)>,
     Unfolding: InlineRule (0, True, True)
                Lib.$fFoldableLine2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <Lib.Line a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
2f4df898c4c0464346eb0a501aa024be
  $fFoldableLine_$ctoList :: Lib.Line a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Lib.Line a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Lib.$fFoldableLine_$cfoldr @ a @ b c n t1)) -}
97e610ce435ee1b9acdb866559c18234
  $fFunctorGrid :: GHC.Base.Functor Lib.Grid
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Grid Lib.$fComonadGrid_$cfmap Lib.$fFunctorGrid_$c<$ -}
97e610ce435ee1b9acdb866559c18234
  $fFunctorGrid_$c<$ :: a -> Lib.Grid b -> Lib.Grid a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Lib.Grid b) ->
                 Lib.$fComonadGrid_$cfmap @ b @ a (\ (ds :: b) -> eta) eta1) -}
2f4df898c4c0464346eb0a501aa024be
  $fFunctorLine :: GHC.Base.Functor Lib.Line
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Line Lib.$fComonadGrid_$cfmap1 Lib.$fFunctorLine_$c<$ -}
2f4df898c4c0464346eb0a501aa024be
  $fFunctorLine_$c<$ :: a -> Lib.Line b -> Lib.Line a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w1 :: Lib.Line b) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 let {
                   f :: b -> a
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ (ds :: b) -> w) -}
                   = \ (ds :: b) -> w
                 } in
                 Lib.Line
                   @ a
                   (GHC.Base.map @ b @ a f ww1)
                   w
                   (GHC.Base.map @ b @ a f ww3) }) -}
a70045846a0bfd0fe034454186b177a8
  $fM2MMaybe[] :: Lib.M2M GHC.Base.Maybe []
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (\ @ a -> Lib.mToList @ a @ a)
                  `cast`
                (Sym (Lib.N:M2M[0] <GHC.Base.Maybe>_N <[]>_N)) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection :: GHC.Classes.Ord Lib.Direction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Direction
                  Lib.$fEqDirection
                  Lib.$fOrdDirection_$ccompare
                  Lib.$fOrdDirection_$c<
                  Lib.$fOrdDirection_$c<=
                  Lib.$fOrdDirection_$c>
                  Lib.$fOrdDirection_$c>=
                  Lib.$fOrdDirection_$cmax
                  Lib.$fOrdDirection_$cmin -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$c< ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: Lib.Direction) (y :: Lib.Direction) ->
                 case Lib.$fOrdDirection_$ccompare x2 y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$c<= ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lib.Direction) (ds1 :: Lib.Direction) ->
                 case ds of wild {
                   Lib.Up
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lib.Up -> GHC.Types.True
                        Lib.Down -> GHC.Types.True }
                   Lib.Down
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lib.Down -> GHC.Types.True }
                   Lib.Left -> case ds1 of wild1 { DEFAULT -> GHC.Types.True }
                   Lib.Right
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.True Lib.Left -> GHC.Types.False } }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$c> ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: Lib.Direction) (y :: Lib.Direction) ->
                 case Lib.$fOrdDirection_$ccompare x2 y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$c>= ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: Lib.Direction) (y :: Lib.Direction) ->
                 case Lib.$fOrdDirection_$ccompare x2 y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$ccompare ::
    Lib.Direction -> Lib.Direction -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (eta :: Lib.Direction) (eta1 :: Lib.Direction) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Ordering
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case eta of wild {
                       Lib.Up
                       -> case eta1 of wild1 {
                            DEFAULT -> GHC.Types.GT
                            Lib.Up -> GHC.Types.LT
                            Lib.Down -> GHC.Types.LT }
                       Lib.Down
                       -> case eta1 of wild1 {
                            DEFAULT -> GHC.Types.GT Lib.Down -> GHC.Types.LT }
                       Lib.Left -> case eta1 of wild1 { DEFAULT -> GHC.Types.LT }
                       Lib.Right
                       -> case eta1 of wild1 {
                            DEFAULT -> GHC.Types.LT Lib.Left -> GHC.Types.GT } }
                 } in
                 case eta of wild {
                   Lib.Up
                   -> case eta1 of wild1 {
                        DEFAULT -> $j GHC.Prim.void# Lib.Up -> GHC.Types.EQ }
                   Lib.Down
                   -> case eta1 of wild1 {
                        DEFAULT -> $j GHC.Prim.void# Lib.Down -> GHC.Types.EQ }
                   Lib.Left
                   -> case eta1 of wild1 {
                        DEFAULT -> $j GHC.Prim.void# Lib.Left -> GHC.Types.EQ }
                   Lib.Right
                   -> case eta1 of wild1 {
                        DEFAULT -> $j GHC.Prim.void# Lib.Right -> GHC.Types.EQ } }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$cmax ::
    Lib.Direction -> Lib.Direction -> Lib.Direction
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x2 :: Lib.Direction) (y :: Lib.Direction) ->
                 case x2 of wild {
                   Lib.Up
                   -> case y of wild1 { DEFAULT -> Lib.Up Lib.Down -> Lib.Down }
                   Lib.Down -> case y of wild1 { DEFAULT -> Lib.Down }
                   Lib.Left -> y
                   Lib.Right
                   -> case y of wild1 { DEFAULT -> wild1 Lib.Left -> Lib.Right } }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fOrdDirection_$cmin ::
    Lib.Direction -> Lib.Direction -> Lib.Direction
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x2 :: Lib.Direction) (y :: Lib.Direction) ->
                 case x2 of wild {
                   Lib.Up
                   -> case y of wild1 {
                        DEFAULT -> wild1 Lib.Up -> Lib.Up Lib.Down -> Lib.Up }
                   Lib.Down -> y
                   Lib.Left -> case y of wild1 { DEFAULT -> Lib.Left }
                   Lib.Right
                   -> case y of wild1 {
                        DEFAULT -> Lib.Right Lib.Left -> Lib.Left } }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    GHC.Classes.Ord (Lib.Grid (GHC.Base.Maybe (b, a)))
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dOrd :: GHC.Classes.Ord a)
                      ($dEq :: GHC.Classes.Eq b).
                  @ (Lib.Grid (GHC.Base.Maybe (b, a)))
                  (Lib.$fOrdGrid_$cp1Ord @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$ccompare @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$c< @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$c<= @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$c> @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$c>= @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$cmax @ a @ b $dOrd $dEq)
                  (Lib.$fOrdGrid_$cmin @ a @ b $dOrd $dEq) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$c< ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a)) -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A)><L,U(U,U(U,U,U),U)><L,U(U,U(U,U,U),U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (x2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (y :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fOrdGrid_$ccompare @ a @ b $dOrd $dEq x2 y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$c<= ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a)) -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,A><S(LS(LSL)L),1*U(A,1*U(A,1*U,A),A)><S(LS(LSL)L),1*U(A,1*U(A,1*U,A),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (w3 :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 case w3 of ww8 { Lib.Grid ww9 ww10 ww11 ->
                 case ww10 of ww12 { Lib.Line ww13 ww14 ww15 ->
                 Lib.$w$c<= @ a @ b w ww6 ww14 } } } }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$c> ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a)) -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A)><L,U(U,U(U,U,U),U)><L,U(U,U(U,U,U),U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (x2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (y :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fOrdGrid_$ccompare @ a @ b $dOrd $dEq x2 y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$c>= ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a)) -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A)><L,U(U,U(U,U,U),U)><L,U(U,U(U,U,U),U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (x2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (y :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fOrdGrid_$ccompare @ a @ b $dOrd $dEq x2 y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$ccompare ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a)) -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A)><L,U(U,U(U,U,U),U)><L,U(U,U(U,U,U),U)>,
     Unfolding: (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (eta :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (eta1 :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fEqGrid_$c==
                        @ (GHC.Base.Maybe (b, a))
                        (GHC.Base.$fEqMaybe
                           @ (b, a)
                           (GHC.Classes.$fEq(,) @ b @ a $dEq (GHC.Classes.$p1Ord @ a $dOrd)))
                        eta
                        eta1 of wild {
                   GHC.Types.False
                   -> case eta of ww { Lib.Grid ww1 ww2 ww3 ->
                      case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                      case eta1 of ww8 { Lib.Grid ww9 ww10 ww11 ->
                      case ww10 of ww12 { Lib.Line ww13 ww14 ww15 ->
                      case Lib.$w$c<= @ a @ b $dOrd ww6 ww14 of wild1 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Types.LT } } } } }
                   GHC.Types.True -> GHC.Types.EQ }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$cmax ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a))
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,A><S(LS(LSL)L),U(U,U(U,U,U),U)><S(LS(LSL)L),U(U,U(U,U,U),U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (x2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (y :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fOrdGrid_$c<= @ a @ b $dOrd $dEq x2 y of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> y }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$cmin ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a))
    -> Lib.Grid (GHC.Base.Maybe (b, a))
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,A><S(LS(LSL)L),U(U,U(U,U,U),U)><S(LS(LSL)L),U(U,U(U,U,U),U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b)
                   (x2 :: Lib.Grid (GHC.Base.Maybe (b, a)))
                   (y :: Lib.Grid (GHC.Base.Maybe (b, a))) ->
                 case Lib.$fOrdGrid_$c<= @ a @ b $dOrd $dEq x2 y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x2 }) -}
97e610ce435ee1b9acdb866559c18234
  $fOrdGrid_$cp1Ord ::
    (GHC.Classes.Ord a, GHC.Classes.Eq b) =>
    GHC.Classes.Eq (Lib.Grid (GHC.Base.Maybe (b, a)))
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,U(C(C1(U)),A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   ($dOrd :: GHC.Classes.Ord a)
                   ($dEq :: GHC.Classes.Eq b) ->
                 Lib.$fEqGrid
                   @ (GHC.Base.Maybe (b, a))
                   (GHC.Base.$fEqMaybe
                      @ (b, a)
                      (GHC.Classes.$fEq(,)
                         @ b
                         @ a
                         $dEq
                         (GHC.Classes.$p1Ord @ a $dOrd)))) -}
18e479a7e65a31cf20551db56459ffe5
  $fOrdGrid_$s$ccompare ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> GHC.Types.Ordering
  {- Arity: 2,
     Strictness: <S(SLL),U(1*U,U(1*U,U,1*U),1*U)><S(SLL),U(1*U,U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                   (w1 :: Lib.Grid
                            (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case w1 of ww4 { Lib.Grid ww5 ww6 ww7 ->
                 Lib.$w$s$ccompare ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
38face69c74bc9252fe607ee7c2ba36c
  $fShowCell :: GHC.Show.Show Lib.Cell
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Cell
                  Lib.$fShowCell_$cshowsPrec
                  Lib.$fShowCell_$cshow
                  Lib.$fShowCell_$cshowList -}
38face69c74bc9252fe607ee7c2ba36c
  $fShowCell1 :: Lib.Cell -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (x2 :: Lib.Cell) (s :: GHC.Base.String)[OneShot] ->
                 case x2 of wild {
                   Lib.Alive -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell3 s
                   Lib.Dead -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell2 s }) -}
5efbd779c5dad56ee49121544ee78082
  $fShowCell2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
53d528ddcfc8f0052776458d63538c91
  $fShowCell3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
38face69c74bc9252fe607ee7c2ba36c
  $fShowCell_$cshow :: Lib.Cell -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Cell) ->
                 case ds of wild {
                   Lib.Alive -> Lib.$fShowCell3 Lib.Dead -> Lib.$fShowCell2 }) -}
38face69c74bc9252fe607ee7c2ba36c
  $fShowCell_$cshowList :: [Lib.Cell] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Lib.Cell]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Lib.Cell Lib.$fShowCell1 ls s) -}
38face69c74bc9252fe607ee7c2ba36c
  $fShowCell_$cshowsPrec ::
    GHC.Types.Int -> Lib.Cell -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int) (x2 :: Lib.Cell) (s :: GHC.Base.String) ->
                 case x2 of wild {
                   Lib.Alive
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowCell3)
                        s
                   Lib.Dead
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowCell2)
                        s }) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fShowDirection :: GHC.Show.Show Lib.Direction
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Direction
                  Lib.$fShowDirection_$cshowsPrec
                  Lib.$fShowDirection_$cshow
                  Lib.$fShowDirection_$cshowList -}
033014881f1804371132f12c2a37aed1
  $fShowDirection1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Right"#) -}
1fcd1d131846b3506a8387399d4beb0a
  $fShowDirection2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Left"#) -}
a517762ef188954d5ae586e8f593f4df
  $fShowDirection3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Down"#) -}
168d03a3b87eafb3a64b7e358f5f20ee
  $fShowDirection4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Up"#) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fShowDirection_$cshow :: Lib.Direction -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: Lib.Direction) ->
                 Lib.$fShowDirection_$cshowsPrec
                   GHC.Show.shows22
                   x2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fShowDirection_$cshowList :: [Lib.Direction] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Direction
                   Lib.$w$cshowsPrec) -}
849e8452416a49d9a7ee131cfd2b5f90
  $fShowDirection_$cshowsPrec ::
    GHC.Types.Int -> Lib.Direction -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Direction)
                   (w2 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec w1 w2) -}
97e610ce435ee1b9acdb866559c18234
  $fShowGrid :: GHC.Show.Show a => GHC.Show.Show (Lib.Grid a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.Grid a)
                  (Lib.$fShowGrid_$cshowsPrec @ a $dShow)
                  (Lib.$fShowGrid_$cshow @ a $dShow)
                  (Lib.$fShowGrid_$cshowList @ a $dShow) -}
ec8c8ea75448bf14caff1bde84078fb6
  $fShowGrid1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
97e610ce435ee1b9acdb866559c18234
  $fShowGrid_$cshow ::
    GHC.Show.Show a => Lib.Grid a -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(A,U,A)><S(SLL),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$w$cshow @ a w ww1 ww2 ww3 }) -}
97e610ce435ee1b9acdb866559c18234
  $fShowGrid_$cshowList ::
    GHC.Show.Show a => [Lib.Grid a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Lib.Grid a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.Grid a)
                   (\ (x2 :: Lib.Grid a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x2 of ww { Lib.Grid ww1 ww2 ww3 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Lib.$w$cshow @ a $dShow ww1 ww2 ww3)
                      s1 })
                   ls
                   s) -}
97e610ce435ee1b9acdb866559c18234
  $fShowGrid_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lib.Grid a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(A,U,A)><L,A><S(SLL),1*U(1*U,1*U(1*U,U,1*U),1*U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x2 :: Lib.Grid a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowGrid_$cshow @ a $dShow x2))
                   s) -}
2f4df898c4c0464346eb0a501aa024be
  $fShowLine :: GHC.Show.Show a => GHC.Show.Show (Lib.Line a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.Line a)
                  (Lib.$fShowLine_$cshowsPrec @ a $dShow)
                  (Lib.$fShowLine_$cshow @ a $dShow)
                  (Lib.$fShowLine_$cshowList @ a $dShow) -}
2f4df898c4c0464346eb0a501aa024be
  $fShowLine_$cshow ::
    GHC.Show.Show a => Lib.Line a -> GHC.Base.String
  {- Arity: 2,
     Strictness: <S(LSL),1*U(A,1*U,A)><S(SLL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Lib.Line a) ->
                 case w1 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$cshow1 @ a w ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fShowLine_$cshowList ::
    GHC.Show.Show a => [Lib.Line a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Lib.Line a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.Line a)
                   (\ (x2 :: Lib.Line a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x2 of ww { Lib.Line ww1 ww2 ww3 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Lib.$w$cshow1 @ a $dShow ww1 ww2 ww3)
                      s1 })
                   ls
                   s) -}
2f4df898c4c0464346eb0a501aa024be
  $fShowLine_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lib.Line a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <S(LSL),1*U(A,1*U,A)><L,A><S(SLL),1*U(1*U,U,1*U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x2 :: Lib.Line a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowLine_$cshow @ a $dShow x2))
                   s) -}
6b4115b92802191b7bdce7a8072a082e
  $fShowNucleobase :: GHC.Show.Show Lib.Nucleobase
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Nucleobase
                  Lib.$fShowNucleobase_$cshowsPrec
                  Lib.$fShowNucleobase_$cshow
                  Lib.$fShowNucleobase_$cshowList -}
97f4be5d3b834cee88df549aedb5db78
  $fShowNucleobase1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "C"#) -}
750caf950595aab4cf7ef9f2be7d031b
  $fShowNucleobase2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "G"#) -}
30e09fff83eb14cdd97f62c6ef3da36e
  $fShowNucleobase3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "U"#) -}
ca8bb6f4c87e637896cd68b35af3c291
  $fShowNucleobase4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A"#) -}
6b4115b92802191b7bdce7a8072a082e
  $fShowNucleobase_$cshow :: Lib.Nucleobase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: Lib.Nucleobase) ->
                 Lib.$fShowNucleobase_$cshowsPrec
                   GHC.Show.shows22
                   x2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6b4115b92802191b7bdce7a8072a082e
  $fShowNucleobase_$cshowList :: [Lib.Nucleobase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Nucleobase
                   Lib.$w$cshowsPrec1) -}
6b4115b92802191b7bdce7a8072a082e
  $fShowNucleobase_$cshowsPrec ::
    GHC.Types.Int -> Lib.Nucleobase -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Nucleobase)
                   (w2 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec1 w1 w2) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fShowNucleotide :: GHC.Show.Show Lib.Nucleotide
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Nucleotide
                  Lib.$fShowNucleotide_$cshowsPrec
                  Lib.$fShowNucleotide_$cshow
                  Lib.$fShowNucleotide_$cshowList -}
a507435bbb1291d2b58fe6be4899ccaa
  $fShowNucleotide1 :: Lib.Nucleotide -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Lib.Nucleotide) ->
                 case w of ww { Lib.Nucleotide ww1 ww2 ww3 ww4 ->
                 Lib.$w$cshowsPrec2 0# ww1 ww2 ww3 ww4 }) -}
cf67c2f245fb7739cce31dc00a433b2b
  $fShowNucleotide2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
97071e6ab0b9641f0d097e0ddb167787
  $fShowNucleotide3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_hbond = "#) -}
a2571e8035b62d3c4e5f6eb4c02a3770
  $fShowNucleotide4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_bond5 = "#) -}
50e8520ebed3f525b0c0c3098f229449
  $fShowNucleotide5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_bond3 = "#) -}
7ab4977ba48a3fbbafe442dd49cc5e47
  $fShowNucleotide6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
a8386290aab99c0386538c95a9b66050
  $fShowNucleotide7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_base = "#) -}
e8a69a50e16606cce1eb3d2bc1fdbf41
  $fShowNucleotide8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nucleotide {"#) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fShowNucleotide_$cshow :: Lib.Nucleotide -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: Lib.Nucleotide) ->
                 Lib.$fShowNucleotide_$cshowsPrec
                   GHC.Show.shows22
                   x2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fShowNucleotide_$cshowList :: [Lib.Nucleotide] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Nucleotide
                   Lib.$fShowNucleotide1) -}
a507435bbb1291d2b58fe6be4899ccaa
  $fShowNucleotide_$cshowsPrec ::
    GHC.Types.Int -> Lib.Nucleotide -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Nucleotide) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Nucleotide ww3 ww4 ww5 ww6 ->
                 Lib.$w$cshowsPrec2 ww1 ww3 ww4 ww5 ww6 } }) -}
97e610ce435ee1b9acdb866559c18234
  $fTraversableGrid :: Data.Traversable.Traversable Lib.Grid
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Grid
                  Lib.$fFunctorGrid
                  Lib.$fFoldableGrid
                  Lib.$fTraversableGrid_$ctraverse
                  Lib.$fTraversableGrid_$csequenceA
                  Lib.$fTraversableGrid_$cmapM
                  Lib.$fTraversableGrid_$csequence -}
97e610ce435ee1b9acdb866559c18234
  $fTraversableGrid_$cmapM ::
    GHC.Base.Monad m => (a -> m b) -> Lib.Grid a -> m (Lib.Grid b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: Lib.Grid a) ->
                 Lib.$fTraversableGrid_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
97e610ce435ee1b9acdb866559c18234
  $fTraversableGrid_$csequence ::
    GHC.Base.Monad m => Lib.Grid (m a) -> m (Lib.Grid a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: Lib.Grid (m a)) ->
                 Lib.$fTraversableGrid_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
97e610ce435ee1b9acdb866559c18234
  $fTraversableGrid_$csequenceA ::
    GHC.Base.Applicative f => Lib.Grid (f a) -> f (Lib.Grid a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U,U),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Lib.Grid (f a)) ->
                 Lib.$fTraversableGrid_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
97e610ce435ee1b9acdb866559c18234
  $fTraversableGrid_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Lib.Grid a -> f (Lib.Grid b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(U,U),C(U),C(C1(U)),A,A)><L,C(U)><S,1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (w2 :: Lib.Grid a) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$w$ctraverse @ f @ a @ b w w1 ww1 ww2 ww3 }) -}
2f4df898c4c0464346eb0a501aa024be
  $fTraversableLine :: Data.Traversable.Traversable Lib.Line
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Line
                  Lib.$fFunctorLine
                  Lib.$fFoldableLine
                  Lib.$fTraversableLine_$ctraverse
                  Lib.$fTraversableLine_$csequenceA
                  Lib.$fTraversableLine_$cmapM
                  Lib.$fTraversableLine_$csequence -}
2f4df898c4c0464346eb0a501aa024be
  $fTraversableLine_$cmapM ::
    GHC.Base.Monad m => (a -> m b) -> Lib.Line a -> m (Lib.Line b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U(1*U,U,1*U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: Lib.Line a) ->
                 Lib.$fTraversableLine_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
2f4df898c4c0464346eb0a501aa024be
  $fTraversableLine_$csequence ::
    GHC.Base.Monad m => Lib.Line (m a) -> m (Lib.Line a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><S,1*U(1*U,U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: Lib.Line (m a)) ->
                 Lib.$fTraversableLine_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
2f4df898c4c0464346eb0a501aa024be
  $fTraversableLine_$csequenceA ::
    GHC.Base.Applicative f => Lib.Line (f a) -> f (Lib.Line a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U,U),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: Lib.Line (f a)) ->
                 Lib.$fTraversableLine_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
2f4df898c4c0464346eb0a501aa024be
  $fTraversableLine_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Lib.Line a -> f (Lib.Line b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(U,U),C(U),C(C1(U)),A,A)><L,C(U)><S,1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (w2 :: Lib.Line a) ->
                 case w2 of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.$w$ctraverse1 @ f @ a @ b w w1 ww1 ww2 ww3 }) -}
6a2010527e1a8dd5876e0cc1d471a0a2
  $sdraw4 ::
    GHC.Base.Maybe Lib.Nucleotide
    -> Graphics.Gloss.Internals.Data.Picture.Picture
  {- Arity: 1, Strictness: <S,1*U>m14,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe Lib.Nucleotide) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Lib.$fDrawableCell1
                   GHC.Base.Just n -> Lib.$fDrawableNucleotide_$cdraw n }) -}
b500a939b6aa1c67be2f7c15ba59c885
  $tc'A :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13393341071267260225##
                   13371384137125814554##
                   Lib.$trModule
                   Lib.$tc'A1) -}
1f03cabf44fc9d6c02923010210b93db
  $tc'A1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'A"#) -}
58714d62ad528597b9ea838566f64587
  $tc'Alive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16053226168311607655##
                   15795437281550049965##
                   Lib.$trModule
                   Lib.$tc'Alive1) -}
98e6a43cd1b0c919af933e64bd068488
  $tc'Alive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Alive"#) -}
0ee992a54ae1621d05a107171f958643
  $tc'C :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8968003938849486081##
                   3464788141253774937##
                   Lib.$trModule
                   Lib.$tc'C1) -}
a80c027effc9450768f5b93983ba3819
  $tc'C1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C"#) -}
85fbedf49fa59fa3f7322a11e815efba
  $tc'C:Drawable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6986844280705499773##
                   8407604663961771087##
                   Lib.$trModule
                   Lib.$tc'C:Drawable1) -}
62b2c25d9153f001d3f99de8402bb6b5
  $tc'C:Drawable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Drawable"#) -}
acedd33173673acd873153e29583ee10
  $tc'C:M2M :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1899779801686936768##
                   13331593670385947195##
                   Lib.$trModule
                   Lib.$tc'C:M2M1) -}
c7d07b6b151d4c70865928c8a7a6d78f
  $tc'C:M2M1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:M2M"#) -}
61b5af382b8f5a3e44e9faae51563cf7
  $tc'Dead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6349474633278482877##
                   12241282196888658179##
                   Lib.$trModule
                   Lib.$tc'Dead1) -}
b275fec5299c002533dc9952134bde7a
  $tc'Dead1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Dead"#) -}
a9fa264ec07f6c316d31a7121a5eb40e
  $tc'Down :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1167738524708899017##
                   2438466500490329864##
                   Lib.$trModule
                   Lib.$tc'Down1) -}
15eabd57d3f70827cd0b2fbebdaf5b4d
  $tc'Down1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Down"#) -}
a89f04283fa94d982e7cf2a2ffae52a9
  $tc'G :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4464663875424812150##
                   4189549899806312870##
                   Lib.$trModule
                   Lib.$tc'G1) -}
8b4e049129831fe1e8dc704522fa45f6
  $tc'G1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'G"#) -}
eef70913040ae635359caf0badf0255f
  $tc'Grid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1480143023129635114##
                   2264428544978995242##
                   Lib.$trModule
                   Lib.$tc'Grid1) -}
112f10f3802949c216386332a931dcf5
  $tc'Grid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Grid"#) -}
f53c9f3d7f3dd373fbca177130c4811b
  $tc'Left :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14954249108404702025##
                   16118792799528490546##
                   Lib.$trModule
                   Lib.$tc'Left1) -}
156d4ebc2edf3296aac037a5e2dd3703
  $tc'Left1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Left"#) -}
27122758f7246d780b13ad7c252e6a8a
  $tc'Line :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13946010125451040012##
                   12714525001848009233##
                   Lib.$trModule
                   Lib.$tc'Line1) -}
f5c1ddc27657093e51a3f29dec4fb85f
  $tc'Line1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Line"#) -}
15e938af00135a41de180efe418b300e
  $tc'Nucleotide :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17428144370819683731##
                   9069290158345973723##
                   Lib.$trModule
                   Lib.$tc'Nucleotide1) -}
1595385792d56621c499a6bc73558b95
  $tc'Nucleotide1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nucleotide"#) -}
2275cd28f9e27ebbb4515288b4b63e3a
  $tc'Right :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8327337199445920321##
                   10063490487815497134##
                   Lib.$trModule
                   Lib.$tc'Right1) -}
ae226e39de9cb5857e55c95e8743626a
  $tc'Right1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Right"#) -}
9fbcde890371b1aa983991ceea6f2f1b
  $tc'U :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18280549539601539941##
                   15966380978843686585##
                   Lib.$trModule
                   Lib.$tc'U1) -}
df94bcb13a6240000aa8231dd272ee16
  $tc'U1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'U"#) -}
3c1d1a22ee4ae22f8421b1944f8fbefe
  $tc'Up :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11194935242754692541##
                   6006787212967125811##
                   Lib.$trModule
                   Lib.$tc'Up1) -}
50a96af041f3cbb98ce0857eb6ccfa66
  $tc'Up1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Up"#) -}
72beb2c818d908db9f9b177906cd265d
  $tcCell :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12828707177429637926##
                   1319182229685797597##
                   Lib.$trModule
                   Lib.$tcCell1) -}
cb7e82f13731e44b97f2cbc1de00807d
  $tcCell1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Cell"#) -}
a7d768ddc77eea6a3a63ce269b242ef0
  $tcDirection :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10668301558205054932##
                   8933123073873777346##
                   Lib.$trModule
                   Lib.$tcDirection1) -}
e5d9b3a78650452ad8cc17710c0aa6fc
  $tcDirection1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Direction"#) -}
2bcc02eba37bcb7a2f770472b2b8bd27
  $tcDrawable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3719026179693351155##
                   9265639718744528027##
                   Lib.$trModule
                   Lib.$tcDrawable1) -}
febde39b53c9944b689772797bad7a69
  $tcDrawable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Drawable"#) -}
721331efa44c328bb196b877c1a9cb2d
  $tcGrid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12486667977903288624##
                   11826328857858257079##
                   Lib.$trModule
                   Lib.$tcGrid1) -}
f73f225a41afeaf1b63ed90406c882f8
  $tcGrid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Grid"#) -}
6c2a23178c561b8374f2311f99fab465
  $tcLine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9118992014625004750##
                   1066791303463079771##
                   Lib.$trModule
                   Lib.$tcLine1) -}
73d86aa1f416e00f20e1c56d16bb54cc
  $tcLine1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Line"#) -}
fb57ab3ead00303e9f2365099cefaef0
  $tcM2M :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16573618559460271216##
                   11378551493854973285##
                   Lib.$trModule
                   Lib.$tcM2M1) -}
f32cea9bd8cf982359c0a96823353093
  $tcM2M1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "M2M"#) -}
ae4356820c73f0e7df56900c297585b4
  $tcNucleobase :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5065815564403207852##
                   8785975537903342494##
                   Lib.$trModule
                   Lib.$tcNucleobase1) -}
93b5802f4cd9e6955ae4733e42ae982f
  $tcNucleobase1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Nucleobase"#) -}
fec51e43220073d6cb187f93351ce0b7
  $tcNucleotide :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5519462433108516867##
                   15213887772964526478##
                   Lib.$trModule
                   Lib.$tcNucleotide1) -}
1c416e6c330c2f58e4b7dcce587af9a8
  $tcNucleotide1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Nucleotide"#) -}
193dd0ed2bb85ad2b1803f6aaee31b94
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
c0895625616c95e8939437828d5f5a37
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
807d9ecbbfb8e69e684df81d8f84ce8f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "DSPB-0.1.0.0-8DbiYz7G17CFksfrEx0ZXk"#) -}
272a4ab79d5891c91659900afe002d14
  $w$c<= ::
    GHC.Classes.Ord a =>
    GHC.Base.Maybe (b, a) -> GHC.Base.Maybe (b, a) -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Ord a)
                   (ww :: GHC.Base.Maybe (b, a))
                   (ww1 :: GHC.Base.Maybe (b, a)) ->
                 case ww of wild {
                   GHC.Base.Nothing
                   -> case case ww1 of wild1 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ a
                             GHC.Base.Just x2
                             -> GHC.Base.Just
                                  @ a
                                  (Data.Tuple.snd @ b @ a x2) } of wild1 { DEFAULT ->
                      GHC.Types.True }
                   GHC.Base.Just x2
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just x3
                        -> GHC.Classes.<=
                             @ a
                             w
                             (case x2 of wild2 { (,) ds1 y -> y })
                             (case x3 of wild2 { (,) ds1 y -> y }) } }) -}
3071639ae7fe9ea45e4e3af2556a5429
  $w$c== ::
    Lib.Nucleobase
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> Lib.Nucleobase
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
9b1bc8a6491d7002e35fa1c5f303e551
  $w$c==1 ::
    GHC.Classes.Eq a =>
    [a] -> a -> [a] -> [a] -> a -> [a] -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U><L,1*U><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a])
                   (ww3 :: [a])
                   (ww4 :: a)
                   (ww5 :: [a]) ->
                 case GHC.Classes.$fEq[]_$c== @ a w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ a w ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.$fEq[]_$c== @ a w ww2 ww5 } }) -}
6db36b4d38b28348552cbd2d9f84f364
  $w$cdraw ::
    Lib.Drawable a =>
    [Lib.Line a]
    -> Lib.Line a
    -> [Lib.Line a]
    -> (# [Graphics.Gloss.Internals.Data.Picture.Picture] #)
  {- Arity: 4, Strictness: <L,C(U)><L,1*U><L,1*U(1*U,U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Lib.Drawable a)
                   (ww :: [Lib.Line a])
                   (ww1 :: Lib.Line a)
                   (ww2 :: [Lib.Line a]) ->
                 (# GHC.Types.:
                      @ Graphics.Gloss.Internals.Data.Picture.Picture
                      (Lib.$fDrawableGrid_$cdraw1 @ a w ww1)
                      (let {
                         z :: [Graphics.Gloss.Internals.Data.Picture.Picture]
                         = GHC.List.zipWith
                             @ GHC.Types.Float
                             @ Graphics.Gloss.Internals.Data.Picture.Picture
                             @ Graphics.Gloss.Internals.Data.Picture.Picture
                             Lib.$fDrawableGrid8
                             Lib.$fDrawableGrid5
                             (GHC.Base.map
                                @ (Lib.Line a)
                                @ Graphics.Gloss.Internals.Data.Picture.Picture
                                (Lib.$fDrawableGrid_$cdraw1 @ a w)
                                ww2)
                       } in
                       letrec {
                         go1 :: [GHC.Types.Float]
                                -> [Graphics.Gloss.Internals.Data.Picture.Picture]
                                -> [Graphics.Gloss.Internals.Data.Picture.Picture]
                           {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                         = \ (ds :: [GHC.Types.Float])
                             (_ys :: [Graphics.Gloss.Internals.Data.Picture.Picture]) ->
                           case ds of wild {
                             [] -> z
                             : ipv ipv1
                             -> case _ys of wild1 {
                                  [] -> z
                                  : ipv2 ipv3
                                  -> GHC.Types.:
                                       @ Graphics.Gloss.Internals.Data.Picture.Picture
                                       (Graphics.Gloss.Internals.Data.Picture.Translate
                                          Lib.$fDrawableGrid4
                                          ipv
                                          ipv2)
                                       (go1 ipv1 ipv3) } }
                       } in
                       go1
                         Lib.$fDrawableGrid1
                         (GHC.Base.map
                            @ (Lib.Line a)
                            @ Graphics.Gloss.Internals.Data.Picture.Picture
                            (Lib.$fDrawableGrid_$cdraw1 @ a w)
                            ww)) #)) -}
6db36b4d38b28348552cbd2d9f84f364
  $w$cdraw1 ::
    Lib.Drawable a =>
    [a]
    -> a
    -> [a]
    -> (# [Graphics.Gloss.Internals.Data.Picture.Picture] #)
  {- Arity: 4, Strictness: <L,C(U)><L,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Lib.Drawable a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 (# GHC.Types.:
                      @ Graphics.Gloss.Internals.Data.Picture.Picture
                      (w `cast` (Lib.N:Drawable[0] <a>_N) ww1)
                      (let {
                         z :: [Graphics.Gloss.Internals.Data.Picture.Picture]
                         = GHC.List.zipWith
                             @ GHC.Types.Float
                             @ Graphics.Gloss.Internals.Data.Picture.Picture
                             @ Graphics.Gloss.Internals.Data.Picture.Picture
                             Lib.$fDrawableGrid_update
                             Lib.$fDrawableGrid1
                             (GHC.Base.map
                                @ a
                                @ Graphics.Gloss.Internals.Data.Picture.Picture
                                w `cast` (Lib.N:Drawable[0] <a>_N)
                                ww2)
                       } in
                       letrec {
                         go1 :: [GHC.Types.Float]
                                -> [Graphics.Gloss.Internals.Data.Picture.Picture]
                                -> [Graphics.Gloss.Internals.Data.Picture.Picture]
                           {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                         = \ (ds :: [GHC.Types.Float])
                             (_ys :: [Graphics.Gloss.Internals.Data.Picture.Picture]) ->
                           case ds of wild {
                             [] -> z
                             : ipv ipv1
                             -> case _ys of wild1 {
                                  [] -> z
                                  : ipv2 ipv3
                                  -> GHC.Types.:
                                       @ Graphics.Gloss.Internals.Data.Picture.Picture
                                       (Lib.$fDrawableGrid_update ipv ipv2)
                                       (go1 ipv1 ipv3) } }
                       } in
                       go1
                         Lib.$fDrawableGrid5
                         (GHC.Base.map
                            @ a
                            @ Graphics.Gloss.Internals.Data.Picture.Picture
                            w `cast` (Lib.N:Drawable[0] <a>_N)
                            ww)) #)) -}
0ed309d81482c78ec49974fc4549be20
  $w$cdraw2 ::
    Lib.Nucleotide
    -> (# [Graphics.Gloss.Internals.Data.Picture.Picture] #)
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,A)>, Inline: [0],
     Unfolding: (\ (w :: Lib.Nucleotide) ->
                 let {
                   p3 :: [Graphics.Gloss.Internals.Data.Picture.Picture]
                   = case w of wild { Lib.Nucleotide ds ds1 ds2 ds3 ->
                     case ds1 of wild1 {
                       GHC.Base.Nothing
                       -> GHC.Types.[] @ Graphics.Gloss.Internals.Data.Picture.Picture
                       GHC.Base.Just ds4
                       -> case ds4 of wild2 {
                            Lib.Up -> Lib.$fDrawableNucleotide26
                            Lib.Down -> Lib.$fDrawableNucleotide25
                            Lib.Left -> Lib.$fDrawableNucleotide24
                            Lib.Right -> Lib.$fDrawableNucleotide23 } } }
                 } in
                 (# GHC.Types.:
                      @ Graphics.Gloss.Internals.Data.Picture.Picture
                      (Graphics.Gloss.Internals.Data.Picture.Color
                         (case w of wild { Lib.Nucleotide ds ds1 ds2 ds3 ->
                          case ds of wild1 {
                            Lib.A -> Graphics.Gloss.Data.Color.blue
                            Lib.U -> Graphics.Gloss.Data.Color.red
                            Lib.G -> Graphics.Gloss.Data.Color.green
                            Lib.C -> Graphics.Gloss.Data.Color.yellow } })
                         Lib.$fDrawableNucleobase1)
                      (case w of wild { Lib.Nucleotide ds ds1 ds2 ds3 ->
                       case ds2 of wild1 {
                         GHC.Base.Nothing -> p3
                         GHC.Base.Just ds4
                         -> case ds4 of wild2 {
                              Lib.Up
                              -> GHC.Types.:
                                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                                   Lib.$fDrawableNucleotide18
                                   p3
                              Lib.Down
                              -> GHC.Types.:
                                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                                   Lib.$fDrawableNucleotide13
                                   p3
                              Lib.Left
                              -> GHC.Types.:
                                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                                   Lib.$fDrawableNucleotide7
                                   p3
                              Lib.Right
                              -> GHC.Types.:
                                   @ Graphics.Gloss.Internals.Data.Picture.Picture
                                   Lib.$fDrawableNucleotide1
                                   p3 } } }) #)) -}
867a768a3242ada5b18f58102659b87d
  $w$cfold ::
    GHC.Base.Monoid m =>
    [Lib.Line m] -> [m] -> m -> [m] -> [Lib.Line m] -> m
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LSL),U(1*U,1*U,A)><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ m
                   (w :: GHC.Base.Monoid m)
                   (ww :: [Lib.Line m])
                   (ww1 :: [m])
                   (ww2 :: m)
                   (ww3 :: [m])
                   (ww4 :: [Lib.Line m]) ->
                 let {
                   f1 :: m -> m -> m = GHC.Base.mappend @ m w
                 } in
                 Lib.$w$cfoldr
                   @ m
                   @ m
                   (\ (x2 :: m) -> f1 x2)
                   (GHC.Base.mempty @ m w)
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
2cca9d9a7f575ff6d3656a43e37ad846
  $w$cfold1 :: GHC.Base.Monoid m => [m] -> m -> [m] -> m
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LSL),U(1*U,1*U,A)><S,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ m
                   (w :: GHC.Base.Monoid m)
                   (ww :: [m])
                   (ww1 :: m)
                   (ww2 :: [m]) ->
                 let {
                   f1 :: m -> m -> m = GHC.Base.mappend @ m w
                 } in
                 Lib.$w$cfoldr1
                   @ m
                   @ m
                   (\ (x2 :: m) -> f1 x2)
                   (GHC.Base.mempty @ m w)
                   ww
                   ww1
                   ww2) -}
2d36c688fb4cd9f17e937bde1a21e97d
  $w$cfoldl ::
    (b -> a -> b)
    -> b -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 (Lib.$w$cfoldr
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                    (\ (x2 :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo b))[OneShot]
                       (eta1 :: b) ->
                     eta `cast` (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                       (w eta1 x2))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo b)>_R
                     ->_R Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    (GHC.Base.id @ b)
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    ww
                    ww1
                    ww2
                    ww3
                    ww4)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                   w1) -}
cd324433193d6678a21219dbe53096e2
  $w$cfoldl' ::
    (b -> a -> b)
    -> b -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 Lib.$w$cfoldr
                   @ a
                   @ (b -> b)
                   (\ (x2 :: a) (k :: b -> b)[OneShot] (z :: b) ->
                    case w z x2 of vx { DEFAULT -> k vx })
                   (GHC.Base.id @ b)
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   w1) -}
e3d9d33dc327f11cfff3aa47240eb059
  $w$cfoldl'1 :: (b -> a -> b) -> b -> [a] -> a -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 Lib.$w$cfoldr1
                   @ a
                   @ (b -> b)
                   (\ (x2 :: a) (k :: b -> b)[OneShot] (z :: b) ->
                    case w z x2 of vx { DEFAULT -> k vx })
                   (GHC.Base.id @ b)
                   ww
                   ww1
                   ww2
                   w1) -}
e59415f24977ee0b52a2046442eb4dbf
  $w$cfoldl1 ::
    (a -> a -> a)
    -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> a
  {- Arity: 6,
     Strictness: <L,C(C1(U))><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 case (Lib.$w$cfoldr
                         @ a
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
                         (\ (x2 :: a)
                            (eta :: Data.Monoid.Dual
                                      (Data.Monoid.Endo (GHC.Base.Maybe a)))[OneShot]
                            (eta1 :: GHC.Base.Maybe a) ->
                          eta
                            `cast`
                          (Data.Monoid.N:Dual[0]
                               (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                            (GHC.Base.Just
                               @ a
                               (case eta1 of wild {
                                  GHC.Base.Nothing -> x2 GHC.Base.Just x3 -> w x3 x2 })))
                           `cast`
                         (<a>_R
                          ->_R <Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))>_R
                          ->_R Sym (Data.Monoid.N:Dual[0]
                                        (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         (GHC.Base.id @ (GHC.Base.Maybe a))
                           `cast`
                         (Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         ww
                         ww1
                         ww2
                         ww3
                         ww4)
                        `cast`
                      (Data.Monoid.N:Dual[0]
                           (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                        (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid8 @ a
                   GHC.Base.Just v -> v }) -}
d5959f151e8ee443f2aceef23e4f2c18
  $w$cfoldl2 :: (a -> a -> a) -> [a] -> a -> [a] -> a
  {- Arity: 4, Strictness: <L,C(C1(U))><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 case (Lib.$w$cfoldr1
                         @ a
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
                         (\ (x2 :: a)
                            (eta :: Data.Monoid.Dual
                                      (Data.Monoid.Endo (GHC.Base.Maybe a)))[OneShot]
                            (eta1 :: GHC.Base.Maybe a) ->
                          eta
                            `cast`
                          (Data.Monoid.N:Dual[0]
                               (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                            (GHC.Base.Just
                               @ a
                               (case eta1 of wild {
                                  GHC.Base.Nothing -> x2 GHC.Base.Just x3 -> w x3 x2 })))
                           `cast`
                         (<a>_R
                          ->_R <Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))>_R
                          ->_R Sym (Data.Monoid.N:Dual[0]
                                        (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         (GHC.Base.id @ (GHC.Base.Maybe a))
                           `cast`
                         (Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         ww
                         ww1
                         ww2)
                        `cast`
                      (Data.Monoid.N:Dual[0]
                           (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                        (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid8 @ a
                   GHC.Base.Just v -> v }) -}
b91bd1764d9d6cf407ee3fdc2a569ecb
  $w$cfoldl3 :: (b -> a -> b) -> b -> [a] -> a -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 (Lib.$w$cfoldr1
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                    (\ (x2 :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo b))[OneShot]
                       (eta1 :: b) ->
                     eta `cast` (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                       (w eta1 x2))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo b)>_R
                     ->_R Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    (GHC.Base.id @ b)
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    ww
                    ww1
                    ww2)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                   w1) -}
5c962666c4a2c04c062bb4b848bd0f96
  $w$cfoldr ::
    (a -> b -> b)
    -> b -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 letrec {
                   go1 :: [Lib.Line a] -> b -> b
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Lib.Line a]) (eta :: b) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case eta of z { DEFAULT ->
                          case y of ww5 { Lib.Line ww6 ww7 ww8 ->
                          go1 ys (Lib.$w$cfoldr1 @ a @ b w z ww6 ww7 ww8) } } }
                 } in
                 go1
                   ww
                   (Lib.$w$cfoldr1
                      @ a
                      @ b
                      w
                      (letrec {
                         go2 :: [Lib.Line a] -> b {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [Lib.Line a]) ->
                           case ds of wild {
                             [] -> w1
                             : y ys
                             -> case y of ww5 { Lib.Line ww6 ww7 ww8 ->
                                Lib.$w$cfoldr1 @ a @ b w (go2 ys) ww6 ww7 ww8 } }
                       } in
                       go2 ww4)
                      ww1
                      ww2
                      ww3)) -}
b173931b948a840558017b02e7ef0bbc
  $w$cfoldr' ::
    (a -> b -> b)
    -> b -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 (Lib.$w$cfoldr
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    (\ (x2 :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))[OneShot]
                       (eta1 :: b -> b) ->
                     eta
                       `cast`
                     (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                       (\ (z :: b) -> case w x2 z of vx { DEFAULT -> eta1 vx }))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo (b -> b))>_R
                     ->_R Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    (GHC.Base.id @ (b -> b))
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    ww
                    ww1
                    ww2
                    ww3
                    ww4)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   w1) -}
7f858b9bea86e40029feebae49f8d149
  $w$cfoldr'1 :: (a -> b -> b) -> b -> [a] -> a -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 (Lib.$w$cfoldr1
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    (\ (x2 :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))[OneShot]
                       (eta1 :: b -> b) ->
                     eta
                       `cast`
                     (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                       (\ (z :: b) -> case w x2 z of vx { DEFAULT -> eta1 vx }))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo (b -> b))>_R
                     ->_R Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    (GHC.Base.id @ (b -> b))
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    ww
                    ww1
                    ww2)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   w1) -}
46cb1890315b0f156c4a2c9a9c012db0
  $w$cfoldr1 :: (a -> b -> b) -> b -> [a] -> a -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 letrec {
                   go1 :: [a] -> b -> b {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [a]) (eta :: b) ->
                     case ds of wild {
                       [] -> eta : y ys -> case eta of z { DEFAULT -> go1 ys (w y z) } }
                 } in
                 go1
                   ww
                   (w ww1
                      (letrec {
                         go2 :: [a] -> b {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [a]) ->
                           case ds of wild { [] -> w1 : y ys -> w y (go2 ys) }
                       } in
                       go2 ww2))) -}
cc7aad8f3ec2347e1c850014abde578c
  $w$cfoldr2 ::
    (a -> a -> a)
    -> [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> a
  {- Arity: 6,
     Strictness: <L,C(C1(U))><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 case Lib.$w$cfoldr
                        @ a
                        @ (GHC.Base.Maybe a)
                        (\ (x2 :: a) (m :: GHC.Base.Maybe a)[OneShot] ->
                         GHC.Base.Just
                           @ a
                           (case m of wild {
                              GHC.Base.Nothing -> x2 GHC.Base.Just y -> w x2 y }))
                        (GHC.Base.Nothing @ a)
                        ww
                        ww1
                        ww2
                        ww3
                        ww4 of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid9 @ a
                   GHC.Base.Just v -> v }) -}
8c28796181468d207044e50fd172e765
  $w$cfoldr3 :: (a -> a -> a) -> [a] -> a -> [a] -> a
  {- Arity: 4, Strictness: <L,C(C1(U))><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> a -> a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 case Lib.$w$cfoldr1
                        @ a
                        @ (GHC.Base.Maybe a)
                        (\ (x2 :: a) (m :: GHC.Base.Maybe a)[OneShot] ->
                         GHC.Base.Just
                           @ a
                           (case m of wild {
                              GHC.Base.Nothing -> x2 GHC.Base.Just y -> w x2 y }))
                        (GHC.Base.Nothing @ a)
                        ww
                        ww1
                        ww2 of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid9 @ a
                   GHC.Base.Just v -> v }) -}
4097ca89c2f345bf10961434674daae1
  $w$clength ::
    [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> GHC.Types.Int
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S,1*U><S,1*U><L,U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 Lib.$w$cfoldr
                   @ a
                   @ (GHC.Types.Int -> GHC.Types.Int)
                   (Lib.$fFoldableGrid6 @ a)
                   (GHC.Base.id @ GHC.Types.Int)
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   Lib.$fFoldableGrid5) -}
4708a7521512934dbb27795c2201678d
  $w$clength1 :: [a] -> a -> [a] -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (ww :: [a]) (ww1 :: a) (ww2 :: [a]) ->
                 Lib.$w$cfoldr1
                   @ a
                   @ (GHC.Types.Int -> GHC.Types.Int)
                   (Lib.$fFoldableGrid6 @ a)
                   (GHC.Base.id @ GHC.Types.Int)
                   ww
                   ww1
                   ww2
                   Lib.$fFoldableGrid5) -}
ce1ebfcbd87a0943a323f01898039998
  $w$cmaximum ::
    GHC.Classes.Ord a =>
    [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> a
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 case (Lib.$w$cfoldr
                         @ a
                         @ (Data.Foldable.Max a)
                         (\ (x2 :: a) (eta :: Data.Foldable.Max a)[OneShot] ->
                          case eta `cast` (Data.Foldable.N:Max[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x2)
                                 `cast`
                               (Sym (Data.Foldable.N:Max[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.>= @ a w x2 ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x2)
                                      `cast`
                                    (Sym (Data.Foldable.N:Max[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                         ww
                         ww1
                         ww2
                         ww3
                         ww4)
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid4 @ a
                   GHC.Base.Just v -> v }) -}
3e8408dfb59d2aea6747f9140d8734dd
  $w$cmaximum1 :: GHC.Classes.Ord a => [a] -> a -> [a] -> a
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 case (Lib.$w$cfoldr1
                         @ a
                         @ (Data.Foldable.Max a)
                         (\ (x2 :: a) (eta :: Data.Foldable.Max a)[OneShot] ->
                          case eta `cast` (Data.Foldable.N:Max[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x2)
                                 `cast`
                               (Sym (Data.Foldable.N:Max[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.>= @ a w x2 ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x2)
                                      `cast`
                                    (Sym (Data.Foldable.N:Max[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                         ww
                         ww1
                         ww2)
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid4 @ a
                   GHC.Base.Just v -> v }) -}
d88e96c1e0410dca8f2db595c94e3466
  $w$cminimum ::
    GHC.Classes.Ord a =>
    [Lib.Line a] -> [a] -> a -> [a] -> [Lib.Line a] -> a
  {- Arity: 6,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 case (Lib.$w$cfoldr
                         @ a
                         @ (Data.Foldable.Min a)
                         (\ (x2 :: a) (eta :: Data.Foldable.Min a)[OneShot] ->
                          case eta `cast` (Data.Foldable.N:Min[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x2)
                                 `cast`
                               (Sym (Data.Foldable.N:Min[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.<= @ a w x2 ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x2)
                                      `cast`
                                    (Sym (Data.Foldable.N:Min[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                         ww
                         ww1
                         ww2
                         ww3
                         ww4)
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid3 @ a
                   GHC.Base.Just v -> v }) -}
6485a3edd9b82f993d0a34a858fe15d6
  $w$cminimum1 :: GHC.Classes.Ord a => [a] -> a -> [a] -> a
  {- Arity: 4,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 case (Lib.$w$cfoldr1
                         @ a
                         @ (Data.Foldable.Min a)
                         (\ (x2 :: a) (eta :: Data.Foldable.Min a)[OneShot] ->
                          case eta `cast` (Data.Foldable.N:Min[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x2)
                                 `cast`
                               (Sym (Data.Foldable.N:Min[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.<= @ a w x2 ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x2)
                                      `cast`
                                    (Sym (Data.Foldable.N:Min[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                         ww
                         ww1
                         ww2)
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing -> Lib.$fFoldableGrid3 @ a
                   GHC.Base.Just v -> v }) -}
3b3e96a3b78e4f55c1a34576fdc6bde5
  $w$cproduct ::
    GHC.Num.Num a =>
    [Lib.Line a]
    -> [a] -> a -> [a] -> [Lib.Line a] -> Data.Monoid.Product a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 let {
                   f1 :: a -> a -> a = GHC.Num.* @ a w
                 } in
                 Lib.$w$cfoldr
                   @ a
                   @ (Data.Monoid.Product a)
                   (\ (x2 :: a) -> f1 x2)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Monoid.N:Product[0] <a>_R)
                    ->_R Sym (Data.Monoid.N:Product[0] <a>_R))
                   (Data.Monoid.$fMonoidProduct2 @ a w)
                     `cast`
                   (Sym (Data.Monoid.N:Product[0] <a>_R))
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
fa1b89366eb08dc5d294a5fa31e1e3ef
  $w$cproduct1 ::
    GHC.Num.Num a => [a] -> a -> [a] -> Data.Monoid.Product a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLSLLLL),U(A,A,1*U,A,A,A,1*C1(U))><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 let {
                   f1 :: a -> a -> a = GHC.Num.* @ a w
                 } in
                 Lib.$w$cfoldr1
                   @ a
                   @ (Data.Monoid.Product a)
                   (\ (x2 :: a) -> f1 x2)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Monoid.N:Product[0] <a>_R)
                    ->_R Sym (Data.Monoid.N:Product[0] <a>_R))
                   (Data.Monoid.$fMonoidProduct2 @ a w)
                     `cast`
                   (Sym (Data.Monoid.N:Product[0] <a>_R))
                   ww
                   ww1
                   ww2) -}
ad5b6178076d20a446ac4a14f0a1f91d
  $w$cshow ::
    GHC.Show.Show a =>
    [Lib.Line a] -> Lib.Line a -> [Lib.Line a] -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,U(A,U,A)><S,1*U><L,1*U(1*U,U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: [Lib.Line a])
                   (ww1 :: Lib.Line a)
                   (ww2 :: [Lib.Line a]) ->
                 letrec {
                   go1 :: [Lib.Line a] -> [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Lib.Line a]) (eta :: [GHC.Types.Char]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case eta of z { DEFAULT ->
                          case y of ww3 { Lib.Line ww4 ww5 ww6 ->
                          go1
                            ys
                            (GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  (Lib.$w$cshow1 @ a w ww4 ww5 ww6)
                                  Lib.$fShowGrid1)
                               z) } } }
                 } in
                 GHC.Base.++
                   @ GHC.Types.Char
                   (go1 ww (GHC.Types.[] @ GHC.Types.Char))
                   (case ww1 of ww3 { Lib.Line ww4 ww5 ww6 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Lib.$w$cshow1 @ a w ww4 ww5 ww6)
                      (GHC.CString.unpackAppendCString#
                         "\n"#
                         (letrec {
                            go2 :: [Lib.Line a] -> [GHC.Types.Char]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds :: [Lib.Line a]) ->
                              case ds of wild {
                                [] -> GHC.Types.[] @ GHC.Types.Char
                                : y ys
                                -> case y of ww7 { Lib.Line ww8 ww9 ww10 ->
                                   GHC.Base.++
                                     @ GHC.Types.Char
                                     (Lib.$w$cshow1 @ a w ww8 ww9 ww10)
                                     (GHC.Base.++ @ GHC.Types.Char Lib.$fShowGrid1 (go2 ys)) } }
                          } in
                          go2 ww2)) })) -}
5f0aba80cac4e120cdff0ab4ac3ba411
  $w$cshow1 :: GHC.Show.Show a => [a] -> a -> [a] -> [GHC.Types.Char]
  {- Arity: 4, Strictness: <S(LSL),1*U(A,1*U,A)><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 let {
                   g :: a -> [GHC.Types.Char] = GHC.Show.show @ a w
                 } in
                 Lib.$w$cfoldr1
                   @ a
                   @ [GHC.Types.Char]
                   (\ (x2 :: a) (b2 :: [GHC.Types.Char])[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (g x2)
                      (GHC.Base.++ @ GHC.Types.Char Lib.$fShowCell2 b2))
                   (GHC.Types.[] @ GHC.Types.Char)
                   ww
                   ww1
                   ww2) -}
849e8452416a49d9a7ee131cfd2b5f90
  $w$cshowsPrec ::
    Lib.Direction -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Lib.Direction) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Lib.Up -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowDirection4 w1
                   Lib.Down -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowDirection3 w1
                   Lib.Left -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowDirection2 w1
                   Lib.Right
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowDirection1 w1 }) -}
6b4115b92802191b7bdce7a8072a082e
  $w$cshowsPrec1 ::
    Lib.Nucleobase -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Lib.Nucleobase) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Lib.A -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowNucleobase4 w1
                   Lib.U -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowNucleobase3 w1
                   Lib.G -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowNucleobase2 w1
                   Lib.C
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowNucleobase1 w1 }) -}
bd6e3da8eca5310cab5891fb257e2480
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Lib.Nucleobase
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Base.Maybe Lib.Direction
    -> GHC.Show.ShowS
  {- Arity: 5, Strictness: <S,U><L,U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.Nucleobase)
                   (ww2 :: GHC.Base.Maybe Lib.Direction)
                   (ww3 :: GHC.Base.Maybe Lib.Direction)
                   (ww4 :: GHC.Base.Maybe Lib.Direction) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Lib.Direction
                       Lib.$fShowDirection
                       Lib.$fFoldableGrid5
                       ww2
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Lib.Direction
                       Lib.$fShowDirection
                       Lib.$fFoldableGrid5
                       ww3
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Lib.Direction
                       Lib.$fShowDirection
                       Lib.$fFoldableGrid5
                       ww4
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x2 :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowNucleotide8
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Lib.$fShowNucleotide7
                          (Lib.$w$cshowsPrec1
                             ww1
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowNucleotide6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Lib.$fShowNucleotide5
                                   (f (GHC.Base.++
                                         @ GHC.Types.Char
                                         Lib.$fShowNucleotide6
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            Lib.$fShowNucleotide4
                                            (f1
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  Lib.$fShowNucleotide6
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Lib.$fShowNucleotide3
                                                     (f2
                                                        (GHC.Base.++
                                                           @ GHC.Types.Char
                                                           Lib.$fShowNucleotide2
                                                           x2))))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x2 :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x2)) }) -}
de04458a69cf1348234f3760c07fbdee
  $w$csum ::
    GHC.Num.Num a =>
    [Lib.Line a]
    -> [a] -> a -> [a] -> [Lib.Line a] -> Data.Monoid.Sum a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S,1*U><S,1*U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 let {
                   f1 :: a -> a -> a = GHC.Num.+ @ a w
                 } in
                 Lib.$w$cfoldr
                   @ a
                   @ (Data.Monoid.Sum a)
                   (\ (x2 :: a) -> f1 x2)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)
                    ->_R Sym (Data.Monoid.N:Sum[0] <a>_R))
                   (Data.Monoid.$fMonoidSum2 @ a w)
                     `cast`
                   (Sym (Data.Monoid.N:Sum[0] <a>_R))
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
c2e42d54a4e586072b5bdc47eba0afe4
  $w$csum1 :: GHC.Num.Num a => [a] -> a -> [a] -> Data.Monoid.Sum a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(SLLLLLL),U(1*U,A,A,A,A,A,1*C1(U))><S,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 let {
                   f1 :: a -> a -> a = GHC.Num.+ @ a w
                 } in
                 Lib.$w$cfoldr1
                   @ a
                   @ (Data.Monoid.Sum a)
                   (\ (x2 :: a) -> f1 x2)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)
                    ->_R Sym (Data.Monoid.N:Sum[0] <a>_R))
                   (Data.Monoid.$fMonoidSum2 @ a w)
                     `cast`
                   (Sym (Data.Monoid.N:Sum[0] <a>_R))
                   ww
                   ww1
                   ww2) -}
97e610ce435ee1b9acdb866559c18234
  $w$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> [Lib.Line a] -> Lib.Line a -> [Lib.Line a] -> f (Lib.Grid b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(U,U),C(U),C(C1(U)),A,A)><L,C(U)><L,1*U><L,1*U(1*U,U,1*U)><L,1*U>,
     Inline: [0] -}
2f4df898c4c0464346eb0a501aa024be
  $w$ctraverse1 ::
    GHC.Base.Applicative f =>
    (a -> f b) -> [a] -> a -> [a] -> f (Lib.Line b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(U,U),C(U),C(C1(U)),A,A)><L,C(U)><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 GHC.Base.<*>
                   @ f
                   w
                   @ [b]
                   @ (Lib.Line b)
                   (GHC.Base.<*>
                      @ f
                      w
                      @ b
                      @ ([b] -> Lib.Line b)
                      (GHC.Base.fmap
                         @ f
                         (GHC.Base.$p1Applicative @ f w)
                         @ [b]
                         @ (b -> [b] -> Lib.Line b)
                         (Lib.Line @ b)
                         (let {
                            $dFunctor :: GHC.Base.Functor f = GHC.Base.$p1Applicative @ f w
                          } in
                          let {
                            z :: f [b] = GHC.Base.pure @ f w @ [b] (GHC.Types.[] @ b)
                          } in
                          letrec {
                            go1 :: [a] -> f [b] {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds :: [a]) ->
                              case ds of wild {
                                [] -> z
                                : y ys
                                -> GHC.Base.<*>
                                     @ f
                                     w
                                     @ [b]
                                     @ [b]
                                     (GHC.Base.fmap
                                        @ f
                                        $dFunctor
                                        @ b
                                        @ ([b] -> [b])
                                        (GHC.Types.: @ b)
                                        (w1 y))
                                     (go1 ys) }
                          } in
                          go1 ww))
                      (w1 ww1))
                   (let {
                      $dFunctor :: GHC.Base.Functor f = GHC.Base.$p1Applicative @ f w
                    } in
                    let {
                      z :: f [b] = GHC.Base.pure @ f w @ [b] (GHC.Types.[] @ b)
                    } in
                    letrec {
                      go1 :: [a] -> f [b] {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z
                          : y ys
                          -> GHC.Base.<*>
                               @ f
                               w
                               @ [b]
                               @ [b]
                               (GHC.Base.fmap
                                  @ f
                                  $dFunctor
                                  @ b
                                  @ ([b] -> [b])
                                  (GHC.Types.: @ b)
                                  (w1 y))
                               (go1 ys) }
                    } in
                    go1 ww2)) -}
e6df9b842d505bd1d4634ad505adefc3
  $w$s$c<= ::
    GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.Maybe
                            (Lib.Nucleotide, Lib.Direction))
                   (ww1 :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)) ->
                 case ww of wild {
                   GHC.Base.Nothing
                   -> case case ww1 of wild1 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                             GHC.Base.Just x2
                             -> GHC.Base.Just
                                  @ Lib.Direction
                                  (Data.Tuple.snd
                                     @ Lib.Nucleotide
                                     @ Lib.Direction
                                     x2) } of wild1 { DEFAULT ->
                      GHC.Types.True }
                   GHC.Base.Just x2
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just x3
                        -> case x2 of wild2 { (,) ds1 y ->
                           case x3 of wild3 { (,) ds2 y1 ->
                           Lib.$fOrdDirection_$c<= y y1 } } } }) -}
8fb041baf5ee04a290cfef918bbb798b
  $w$s$c== ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> GHC.Types.Bool
  {- Arity: 6,
     Strictness: <S,1*U><L,1*U(1*U,1*U,1*U)><L,1*U><S,1*U><L,1*U(1*U,1*U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Lib.Line
                             (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww1 :: Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                   (ww2 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww3 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww4 :: Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                   (ww5 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                        Lib.$fEqGrid2
                        ww
                        ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of ww6 { Lib.Line ww7 ww8 ww9 ->
                      case ww4 of ww10 { Lib.Line ww11 ww12 ww13 ->
                      case Lib.$w$s$c==1 ww7 ww8 ww9 ww11 ww12 ww13 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> GHC.Classes.$fEq[]_$c==
                             @ (Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                             Lib.$fEqGrid2
                             ww2
                             ww5 } } } }) -}
7b5f13cb4ce44651bea166ba84bed308
  $w$s$c==1 ::
    [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe
                             (Lib.Nucleotide, Lib.Direction)])
                   (ww1 :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   (ww2 :: [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)])
                   (ww3 :: [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)])
                   (ww4 :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   (ww5 :: [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                        Lib.$fEqGrid_$s$fEqMaybe
                        ww
                        ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                                  Lib.$fEqGrid_$s$fEqMaybe
                                  ww2
                                  ww5
                             GHC.Base.Just ipv -> GHC.Types.False }
                        GHC.Base.Just a1
                        -> case ww4 of wild2 {
                             GHC.Base.Nothing -> GHC.Types.False
                             GHC.Base.Just b1
                             -> case a1 of ww6 { (,) ww7 ww8 ->
                                case b1 of ww9 { (,) ww10 ww11 ->
                                case ww7 of ww12 { Lib.Nucleotide ww13 ww14 ww15 ww16 ->
                                case ww10 of ww17 { Lib.Nucleotide ww18 ww19 ww20 ww21 ->
                                case Lib.$w$c== ww13 ww14 ww15 ww16 ww18 ww19 ww20 ww21 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww8 of wild4 {
                                       Lib.Up
                                       -> case ww11 of wild5 {
                                            DEFAULT -> GHC.Types.False
                                            Lib.Up
                                            -> GHC.Classes.$fEq[]_$c==
                                                 @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                                                 Lib.$fEqGrid_$s$fEqMaybe
                                                 ww2
                                                 ww5 }
                                       Lib.Down
                                       -> case ww11 of wild5 {
                                            DEFAULT -> GHC.Types.False
                                            Lib.Down
                                            -> GHC.Classes.$fEq[]_$c==
                                                 @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                                                 Lib.$fEqGrid_$s$fEqMaybe
                                                 ww2
                                                 ww5 }
                                       Lib.Left
                                       -> case ww11 of wild5 {
                                            DEFAULT -> GHC.Types.False
                                            Lib.Left
                                            -> GHC.Classes.$fEq[]_$c==
                                                 @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                                                 Lib.$fEqGrid_$s$fEqMaybe
                                                 ww2
                                                 ww5 }
                                       Lib.Right
                                       -> case ww11 of wild5 {
                                            DEFAULT -> GHC.Types.False
                                            Lib.Right
                                            -> GHC.Classes.$fEq[]_$c==
                                                 @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                                                 Lib.$fEqGrid_$s$fEqMaybe
                                                 ww2
                                                 ww5 } } } } } } } } } }) -}
3124abd4f79fca509d1ec170491f4bb0
  $w$s$ccompare ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> GHC.Types.Ordering
  {- Arity: 6,
     Strictness: <S,1*U><L,U(1*U,U,1*U)><L,1*U><S,1*U><L,U(1*U,U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Lib.Line
                             (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww1 :: Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                   (ww2 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww3 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww4 :: Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                   (ww5 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]) ->
                 case Lib.$w$s$c== ww ww1 ww2 ww3 ww4 ww5 of wild {
                   GHC.Types.False
                   -> case ww1 of ww6 { Lib.Line ww7 ww8 ww9 ->
                      case ww4 of ww10 { Lib.Line ww11 ww12 ww13 ->
                      case Lib.$w$s$c<= ww8 ww12 of wild1 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Types.LT } } }
                   GHC.Types.True -> GHC.Types.EQ }) -}
a84a44839adadd204ebc513f5e8e8762
  $wappendToLine :: [a] -> a -> [a] -> a -> (# [a], a, [a] #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U>,
     Inline: [0] -}
a23b534c759ae2f5238f21ede01e27db
  $wcheckColl ::
    [Lib.Line (GHC.Base.Maybe a)]
    -> [GHC.Base.Maybe a]
    -> [GHC.Base.Maybe a]
    -> [Lib.Line (GHC.Base.Maybe a)]
    -> (# GHC.Base.Maybe Lib.Direction,
          [GHC.Base.Maybe Lib.Direction] #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line (GHC.Base.Maybe a)])
                   (ww1 :: [GHC.Base.Maybe a])
                   (ww2 :: [GHC.Base.Maybe a])
                   (ww3 :: [Lib.Line (GHC.Base.Maybe a)]) ->
                 (# case ww of wild {
                      [] -> Lib.checkColl4
                      : ds ds1
                      -> case ds of wild1 { Lib.Line ds2 ds3 ds4 ->
                         case ds3 of wild2 {
                           GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                           GHC.Base.Just x2 -> Lib.checkColl4 } } },
                    GHC.Types.:
                      @ (GHC.Base.Maybe Lib.Direction)
                      (case ww3 of wild {
                         [] -> Lib.checkColl3
                         : ds ds1
                         -> case ds of wild1 { Lib.Line ds2 ds3 ds4 ->
                            case ds3 of wild2 {
                              GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                              GHC.Base.Just ds5 -> Lib.checkColl3 } } })
                      (GHC.Types.:
                         @ (GHC.Base.Maybe Lib.Direction)
                         (case ww1 of wild {
                            [] -> Lib.checkColl2
                            : ds ds1
                            -> case ds of wild1 {
                                 GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                                 GHC.Base.Just ds2 -> Lib.checkColl2 } })
                         (GHC.Types.:
                            @ (GHC.Base.Maybe Lib.Direction)
                            (case ww2 of wild {
                               [] -> Lib.checkColl1
                               : ds ds1
                               -> case ds of wild1 {
                                    GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                                    GHC.Base.Just ds2 -> Lib.checkColl1 } })
                            (GHC.Types.[] @ (GHC.Base.Maybe Lib.Direction)))) #)) -}
d57469e7dd4bf3fe06384a5b86b4e409
  $wconwayUpdate ::
    [Lib.Line Lib.Cell]
    -> [Lib.Cell]
    -> Lib.Cell
    -> [Lib.Cell]
    -> [Lib.Line Lib.Cell]
    -> Lib.Cell
  {- Arity: 5, HasNoCafRefs, Strictness: <S,U><L,U><S,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Lib.Line Lib.Cell])
                   (ww1 :: [Lib.Cell])
                   (ww2 :: Lib.Cell)
                   (ww3 :: [Lib.Cell])
                   (ww4 :: [Lib.Line Lib.Cell]) ->
                 case Lib.$wgo
                        (Lib.$wmooresNeighb
                           @ Lib.Cell
                           ww
                           (Lib.Line @ Lib.Cell ww1 ww2 ww3)
                           ww4)
                        0# of ww5 { DEFAULT ->
                 case ww2 of wild {
                   Lib.Alive
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww5 3#) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># 2# ww5) of wild2 {
                             GHC.Types.False -> Lib.Alive GHC.Types.True -> Lib.Dead }
                        GHC.Types.True -> Lib.Dead }
                   Lib.Dead
                   -> case ww5 of wild1 {
                        DEFAULT -> Lib.Dead 3# -> Lib.Alive } } }) -}
b6ce977af0a664510b723f948e7af7a3
  $wfl2dir :: GHC.Prim.Float# -> Lib.Direction
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Float#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.ltFloat# ww 0.25#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.ltFloat# ww 0.5#) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.ltFloat# ww 0.75#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.ltFloat# ww 1.0#) of wild3 {
                                  GHC.Types.False -> Lib.Left GHC.Types.True -> Lib.Down }
                             GHC.Types.True -> Lib.Up }
                        GHC.Types.True -> Lib.Right }
                   GHC.Types.True -> Lib.Left }) -}
f2bf3e4213190334fa3e41868f112a97
  $wgo :: [Lib.Cell] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
97e610ce435ee1b9acdb866559c18234
  $wgridConfigurations ::
    [Lib.Line a]
    -> Lib.Line a
    -> [Lib.Line a]
    -> (# [Lib.Line (Lib.Grid a)], Lib.Line (Lib.Grid a),
          [Lib.Line (Lib.Grid a)] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U(U,U,U)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line a])
                   (ww1 :: Lib.Line a)
                   (ww2 :: [Lib.Line a]) ->
                 let {
                   wild :: Lib.Grid a = Lib.Grid @ a ww ww1 ww2
                 } in
                 let {
                   lvl31 :: (Lib.Grid a -> Lib.Grid a) -> Lib.Grid a
                     {- Arity: 1, Strictness: <C(S),1*C1(U(U,U,U))>,
                        Unfolding: InlineRule (1, True, True)
                                   (\ (ds :: Lib.Grid a -> Lib.Grid a) -> ds wild) -}
                   = \ (ds :: Lib.Grid a -> Lib.Grid a) -> ds wild
                 } in
                 let {
                   confs :: forall a1.
                            [a1] -> (Lib.Grid a -> Lib.Grid a) -> [Lib.Grid a]
                     {- Arity: 2, Strictness: <S,1*U><L,C(U)> -}
                   = \ @ a1 (ls :: [a1]) (f :: Lib.Grid a -> Lib.Grid a)[OneShot] ->
                     letrec {
                       go1 :: [a1]
                              -> (Lib.Grid a -> Lib.Grid a) -> [Lib.Grid a -> Lib.Grid a]
                         {- Arity: 2, Strictness: <S,1*U><L,C(U(U,U,U))> -}
                       = \ (ds :: [a1]) (eta :: Lib.Grid a -> Lib.Grid a) ->
                         case ds of wild1 {
                           [] -> GHC.Types.[] @ (Lib.Grid a -> Lib.Grid a)
                           : y ys
                           -> let {
                                b' :: Lib.Grid a -> Lib.Grid a
                                  {- Arity: 1, Strictness: <L,U>,
                                     Unfolding: InlineRule (1, True, False)
                                                (\ (x2 :: Lib.Grid a) -> eta (f x2)) -}
                                = \ (x2 :: Lib.Grid a) -> eta (f x2)
                              } in
                              GHC.Types.: @ (Lib.Grid a -> Lib.Grid a) b' (go1 ys b') }
                     } in
                     GHC.Base.map
                       @ (Lib.Grid a -> Lib.Grid a)
                       @ (Lib.Grid a)
                       lvl31
                       (go1 ls (GHC.Base.id @ (Lib.Grid a)))
                 } in
                 (# GHC.Base.map
                      @ (Lib.Grid a)
                      @ (Lib.Line (Lib.Grid a))
                      (Lib.horizontalConfigurations @ a)
                      (confs @ (Lib.Line a) ww (Lib.moveUpGrid @ a)),
                    case ww1 of ww3 { Lib.Line ww4 ww5 ww6 ->
                    case Lib.$whorizontalConfigurations
                           @ a
                           ww
                           ww4
                           ww5
                           ww6
                           ww2 of ww7 { (#,,#) ww8 ww9 ww10 ->
                    Lib.Line @ (Lib.Grid a) ww8 ww9 ww10 } },
                    GHC.Base.map
                      @ (Lib.Grid a)
                      @ (Lib.Line (Lib.Grid a))
                      (Lib.horizontalConfigurations @ a)
                      (confs @ (Lib.Line a) ww2 (Lib.moveDownGrid @ a)) #)) -}
a1dcd2984508571316538f386a2062b7
  $whorizNeighb :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [a]) (ww1 :: [a]) ->
                 case ww of wild {
                   []
                   -> case ww1 of wild1 {
                        [] -> GHC.Types.[] @ a
                        : b ds -> GHC.Types.: @ a b (GHC.Types.[] @ a) }
                   : a1 ds
                   -> case ww1 of wild1 {
                        [] -> GHC.Types.: @ a a1 (GHC.Types.[] @ a)
                        : b ds1
                        -> GHC.Types.:
                             @ a
                             a1
                             (GHC.Types.: @ a b (GHC.Types.[] @ a)) } }) -}
97e610ce435ee1b9acdb866559c18234
  $whorizontalConfigurations ::
    [Lib.Line a]
    -> [a]
    -> a
    -> [a]
    -> [Lib.Line a]
    -> (# [Lib.Grid a], Lib.Grid a, [Lib.Grid a] #)
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: a)
                   (ww3 :: [a])
                   (ww4 :: [Lib.Line a]) ->
                 let {
                   ds :: Lib.Line a = Lib.Line @ a ww1 ww2 ww3
                 } in
                 let {
                   wild :: Lib.Grid a = Lib.Grid @ a ww ds ww4
                 } in
                 let {
                   lvl31 :: (Lib.Grid a -> Lib.Grid a) -> Lib.Grid a
                     {- Arity: 1, Strictness: <C(S),1*C1(U(U,U,U))>,
                        Unfolding: InlineRule (1, True, True)
                                   (\ (ds1 :: Lib.Grid a -> Lib.Grid a) -> ds1 wild) -}
                   = \ (ds1 :: Lib.Grid a -> Lib.Grid a) -> ds1 wild
                 } in
                 let {
                   confs :: forall a1.
                            [a1] -> (Lib.Grid a -> Lib.Grid a) -> [Lib.Grid a]
                     {- Arity: 2, Strictness: <S,1*U><L,C(U)> -}
                   = \ @ a1 (ls :: [a1]) (f :: Lib.Grid a -> Lib.Grid a)[OneShot] ->
                     letrec {
                       go1 :: [a1]
                              -> (Lib.Grid a -> Lib.Grid a) -> [Lib.Grid a -> Lib.Grid a]
                         {- Arity: 2, Strictness: <S,1*U><L,C(U(U,U,U))> -}
                       = \ (ds1 :: [a1]) (eta :: Lib.Grid a -> Lib.Grid a) ->
                         case ds1 of wild1 {
                           [] -> GHC.Types.[] @ (Lib.Grid a -> Lib.Grid a)
                           : y ys
                           -> let {
                                b' :: Lib.Grid a -> Lib.Grid a
                                  {- Arity: 1, Strictness: <L,U>,
                                     Unfolding: InlineRule (1, True, False)
                                                (\ (x2 :: Lib.Grid a) -> eta (f x2)) -}
                                = \ (x2 :: Lib.Grid a) -> eta (f x2)
                              } in
                              GHC.Types.: @ (Lib.Grid a -> Lib.Grid a) b' (go1 ys b') }
                     } in
                     GHC.Base.map
                       @ (Lib.Grid a -> Lib.Grid a)
                       @ (Lib.Grid a)
                       lvl31
                       (go1 ls (GHC.Base.id @ (Lib.Grid a)))
                 } in
                 (# confs @ a ww1 (Lib.moveLeftGrid @ a), wild,
                    confs @ a ww3 (Lib.moveRightGrid @ a) #)) -}
2f49b2911ae58b12b589a8039b86e05f
  $wlistPart ::
    (a -> GHC.Base.Maybe Lib.Direction)
    -> (a -> GHC.Base.Maybe Lib.Direction)
    -> [Lib.Line (GHC.Base.Maybe a)]
    -> [GHC.Base.Maybe a]
    -> GHC.Base.Maybe a
    -> [GHC.Base.Maybe a]
    -> [Lib.Line (GHC.Base.Maybe a)]
    -> [Lib.Grid (GHC.Base.Maybe a)]
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(U)><L,C(U)><L,U><L,U><S,U><L,U><L,U>,
     Inline: [0] -}
1cb3e6f0a2725ae7cc5a278c05dc11e1
  $wlistPartMol ::
    [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
    -> [GHC.Base.Maybe Lib.Nucleotide]
    -> GHC.Base.Maybe Lib.Nucleotide
    -> [GHC.Base.Maybe Lib.Nucleotide]
    -> [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
    -> [Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)]
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U><L,U>,
     Inline: [0] -}
c0da7f8652a5f739cc991eac8a79d90c
  $wlistPartMolD ::
    (a -> GHC.Base.Maybe Lib.Direction)
    -> [Lib.Line (GHC.Base.Maybe a)]
    -> [GHC.Base.Maybe a]
    -> GHC.Base.Maybe a
    -> [GHC.Base.Maybe a]
    -> [Lib.Line (GHC.Base.Maybe a)]
    -> [Lib.Grid (GHC.Base.Maybe a)]
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,C(U)><L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
d4cf97e6c852092ae169eb7614c1e481
  $wlistPartTup ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, b))]
    -> [GHC.Base.Maybe (Lib.Nucleotide, b)]
    -> GHC.Base.Maybe (Lib.Nucleotide, b)
    -> [GHC.Base.Maybe (Lib.Nucleotide, b)]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, b))]
    -> [Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, b))]
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U><L,U>,
     Inline: [0] -}
554da52e230b650c6b15868237dc28d4
  $wlowerNeighb :: [Lib.Line a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [Lib.Line a]) ->
                 case ww of wild {
                   [] -> GHC.Types.[] @ a
                   : u ds
                   -> case u of wild1 { Lib.Line ds1 x2 ds2 ->
                      case ds1 of wild2 {
                        []
                        -> case ds2 of wild3 {
                             [] -> GHC.Types.: @ a x2 (GHC.Types.[] @ a)
                             : r ds3
                             -> GHC.Types.: @ a x2 (GHC.Types.: @ a r (GHC.Types.[] @ a)) }
                        : l ds3
                        -> case ds2 of wild3 {
                             [] -> GHC.Types.: @ a l (GHC.Types.: @ a x2 (GHC.Types.[] @ a))
                             : r ds4
                             -> GHC.Types.:
                                  @ a
                                  l
                                  (GHC.Types.:
                                     @ a
                                     x2
                                     (GHC.Types.: @ a r (GHC.Types.[] @ a))) } } } }) -}
d26a75f0b4bc74e143fcffaa9005e8df
  $wlvl ::
    [Lib.Direction]
    -> Lib.Direction -> (# Lib.Direction, GHC.Types.Int #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (w :: [Lib.Direction]) (w1 :: Lib.Direction) ->
                 (# w1,
                    letrec {
                      $wgo1 :: [Lib.Direction] -> GHC.Prim.Int# -> GHC.Prim.Int#
                        {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                      = \ (w2 :: [Lib.Direction]) (ww :: GHC.Prim.Int#) ->
                        case w2 of wild {
                          [] -> ww
                          : y ys
                          -> case w1 of wild1 {
                               Lib.Up
                               -> case y of wild2 {
                                    DEFAULT -> $wgo1 ys ww Lib.Up -> $wgo1 ys (GHC.Prim.+# ww 1#) }
                               Lib.Down
                               -> case y of wild2 {
                                    DEFAULT -> $wgo1 ys ww
                                    Lib.Down -> $wgo1 ys (GHC.Prim.+# ww 1#) }
                               Lib.Left
                               -> case y of wild2 {
                                    DEFAULT -> $wgo1 ys ww
                                    Lib.Left -> $wgo1 ys (GHC.Prim.+# ww 1#) }
                               Lib.Right
                               -> case y of wild2 {
                                    DEFAULT -> $wgo1 ys ww
                                    Lib.Right -> $wgo1 ys (GHC.Prim.+# ww 1#) } } }
                    } in
                    case $wgo1 w 0# of ww { DEFAULT -> GHC.Types.I# ww } #)) -}
08fd12190c6d5b7c12c152b17cee78a5
  $wmolDir ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> GHC.Base.Maybe (Lib.Direction, GHC.Types.Int)
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Lib.Line
                             (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))])
                   (ww1 :: [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)])
                   (ww2 :: GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   (ww3 :: [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)])
                   (ww4 :: [Lib.Line
                              (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]) ->
                 let {
                   x2 :: [Lib.Direction] = Lib.$wnucNeighb ww ww1 ww2 ww3 ww4
                 } in
                 letrec {
                   go1 :: [(Lib.Direction, GHC.Types.Int)]
                          -> GHC.Base.Maybe (Lib.Direction, GHC.Types.Int)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Lib.Direction, GHC.Types.Int)]) ->
                     case ds of wild {
                       [] -> GHC.Base.Nothing @ (Lib.Direction, GHC.Types.Int)
                       : y ys
                       -> case GHC.List.elem
                                 @ Lib.Direction
                                 Lib.$fEqDirection
                                 (case y of wild1 { (,) x3 ds1 -> x3 })
                                 x2 of wild1 {
                            GHC.Types.False
                            -> case go1 ys of wild2 {
                                 GHC.Base.Nothing
                                 -> GHC.Base.Just @ (Lib.Direction, GHC.Types.Int) y
                                 GHC.Base.Just ipv
                                 -> GHC.Base.Just
                                      @ (Lib.Direction, GHC.Types.Int)
                                      (Lib.biggersnd_$sbiggersnd @ Lib.Direction y ipv) }
                            GHC.Types.True -> go1 ys } }
                 } in
                 let {
                   eta :: [Lib.Direction]
                   = Data.Maybe.mapMaybe
                       @ (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                       @ Lib.Direction
                       Lib.molDir3
                       (Lib.$wlistPartTup @ Lib.Direction ww ww1 ww2 ww3 ww4)
                 } in
                 go1
                   (Data.OldList.sortBy
                      @ (Lib.Direction, GHC.Types.Int)
                      Lib.molDir2
                      (GHC.Base.map
                         @ Lib.Direction
                         @ (Lib.Direction, GHC.Types.Int)
                         (Lib.molDir1 eta)
                         eta))) -}
a5069ba402569f5faa95108c83977726
  $wmooresNeighb :: [Lib.Line a] -> Lib.Line a -> [Lib.Line a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(1*U,A,1*U)><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line a])
                   (ww1 :: Lib.Line a)
                   (ww2 :: [Lib.Line a]) ->
                 GHC.Base.++
                   @ a
                   (Lib.$wupperNeighb @ a ww)
                   (GHC.Base.++
                      @ a
                      (Lib.$wlowerNeighb @ a ww2)
                      (case ww1 of wild { Lib.Line ds ds1 ds2 ->
                       case ds of wild1 {
                         []
                         -> case ds2 of wild2 {
                              [] -> GHC.Types.[] @ a
                              : b ds3 -> GHC.Types.: @ a b (GHC.Types.[] @ a) }
                         : a1 ds3
                         -> case ds2 of wild2 {
                              [] -> GHC.Types.: @ a a1 (GHC.Types.[] @ a)
                              : b ds4
                              -> GHC.Types.:
                                   @ a
                                   a1
                                   (GHC.Types.: @ a b (GHC.Types.[] @ a)) } } }))) -}
70ddd764fb0df37b7a76908828513abf
  $wneuNeigh ::
    [Lib.Line a] -> [a] -> [a] -> [Lib.Line a] -> [(Lib.Direction, a)]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: [Lib.Line a])
                   (ww1 :: [a])
                   (ww2 :: [a])
                   (ww3 :: [Lib.Line a]) ->
                 Data.Maybe.catMaybes1
                   @ (Lib.Direction, a)
                   (GHC.Types.:
                      @ (GHC.Base.Maybe (Lib.Direction, a))
                      (case ww of wild {
                         [] -> GHC.Base.Nothing @ (Lib.Direction, a)
                         : ds ds1
                         -> case ds of wild1 { Lib.Line ds2 x2 ds3 ->
                            GHC.Base.Just @ (Lib.Direction, a) (Lib.Up, x2) } })
                      (GHC.Types.:
                         @ (GHC.Base.Maybe (Lib.Direction, a))
                         (case ww3 of wild {
                            [] -> GHC.Base.Nothing @ (Lib.Direction, a)
                            : ds ds1
                            -> case ds of wild1 { Lib.Line ds2 x2 ds3 ->
                               GHC.Base.Just @ (Lib.Direction, a) (Lib.Down, x2) } })
                         (GHC.Types.:
                            @ (GHC.Base.Maybe (Lib.Direction, a))
                            (case ww1 of wild {
                               [] -> GHC.Base.Nothing @ (Lib.Direction, a)
                               : x2 ds -> GHC.Base.Just @ (Lib.Direction, a) (Lib.Left, x2) })
                            (GHC.Types.:
                               @ (GHC.Base.Maybe (Lib.Direction, a))
                               (case ww2 of wild {
                                  [] -> GHC.Base.Nothing @ (Lib.Direction, a)
                                  : x2 ds -> GHC.Base.Just @ (Lib.Direction, a) (Lib.Right, x2) })
                               (GHC.Types.[] @ (GHC.Base.Maybe (Lib.Direction, a)))))))) -}
8e2e5ef9e18b9a57c22f9d9404dd649e
  $wnucNeighb ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [Lib.Direction]
  {- Arity: 5, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U><L,U>,
     Inline: [0] -}
3f6bb576457d0a4c7cf72869ea86f3a8
  $wnucNeighbN ::
    (Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction)
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [Lib.Direction]
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,C(U)><L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
0f1e4f2617f8422424069275e06b6f2c
  $wupdateNuc ::
    [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)
    -> [GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)]
    -> [Lib.Line (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))]
    -> GHC.Base.Maybe Lib.Nucleotide
  {- Arity: 5, Strictness: <L,U><L,U><S,U><L,U><L,U>, Inline: [0] -}
c6cc0691b4509ea187e59cd7848f9367
  $wupperNeighb :: [Lib.Line a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [Lib.Line a]) ->
                 case ww of wild {
                   [] -> GHC.Types.[] @ a
                   : u ds
                   -> case u of wild1 { Lib.Line ds1 x2 ds2 ->
                      case ds1 of wild2 {
                        []
                        -> case ds2 of wild3 {
                             [] -> GHC.Types.: @ a x2 (GHC.Types.[] @ a)
                             : r ds3
                             -> GHC.Types.: @ a x2 (GHC.Types.: @ a r (GHC.Types.[] @ a)) }
                        : l ds3
                        -> case ds2 of wild3 {
                             [] -> GHC.Types.: @ a l (GHC.Types.: @ a x2 (GHC.Types.[] @ a))
                             : r ds4
                             -> GHC.Types.:
                                  @ a
                                  l
                                  (GHC.Types.:
                                     @ a
                                     x2
                                     (GHC.Types.: @ a r (GHC.Types.[] @ a))) } } } }) -}
a7a572bb0f7da977a08cac9a6ac1688c
  $wxs :: GHC.Prim.Int# -> (# GHC.Base.Maybe a, [GHC.Base.Maybe a] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
179d91119263973db4ed931f71740951
  $wxs1 ::
    GHC.Prim.Int# -> (# GHC.Base.Maybe a, [GHC.Base.Maybe a] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
7fc02eb98635b9f9b8aea7bf85ba4a86
  $wxs10 ::
    GHC.Prim.Int#
    -> (# Lib.Line (GHC.Base.Maybe Lib.Nucleotide),
          [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e84df23304b16f6f6f2c0f6c89a5fa4f
  $wxs11 ::
    GHC.Prim.Int#
    -> (# Lib.Line (GHC.Base.Maybe Lib.Nucleotide),
          [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f17bb08e255bce0376688e7c7f6e6095
  $wxs2 ::
    GHC.Prim.Int# -> (# Lib.Line Lib.Cell, [Lib.Line Lib.Cell] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
07d5346ebd383d1a1cdfaf95f3198c83
  $wxs3 :: GHC.Prim.Int# -> [Lib.Cell]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
442e16e22a2a05d5906698d1a907c197
  $wxs4 :: GHC.Prim.Int# -> [Lib.Cell]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
6d70e988e49b9ee634b70791ba2fea35
  $wxs5 ::
    GHC.Prim.Int# -> (# Lib.Line Lib.Cell, [Lib.Line Lib.Cell] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
72a69f74e79857214f46db16b39c9ea2
  $wxs6 ::
    GHC.Prim.Int#
    -> (# Lib.Line (GHC.Base.Maybe Lib.Nucleotide),
          [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
a75288a575d51e81b80d8b291f9698c6
  $wxs7 ::
    GHC.Prim.Int#
    -> (# GHC.Base.Maybe Lib.Nucleotide,
          [GHC.Base.Maybe Lib.Nucleotide] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
e9e5edc3866c7f11964fea032b48534b
  $wxs8 ::
    GHC.Prim.Int#
    -> (# GHC.Base.Maybe Lib.Nucleotide,
          [GHC.Base.Maybe Lib.Nucleotide] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
e45f7cf6b5d90c60bc65d984a74e6a43
  $wxs9 ::
    GHC.Prim.Int#
    -> (# Lib.Line (GHC.Base.Maybe Lib.Nucleotide),
          [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
38face69c74bc9252fe607ee7c2ba36c
  data Cell = Alive | Dead
849e8452416a49d9a7ee131cfd2b5f90
  data Direction = Up | Down | Left | Right
6db36b4d38b28348552cbd2d9f84f364
  class Drawable a where
    draw :: a -> Graphics.Gloss.Internals.Data.Picture.Picture
    {-# MINIMAL draw #-}
97e610ce435ee1b9acdb866559c18234
  data Grid a
    = Grid {_up :: [Lib.Line a],
            _mid :: Lib.Line a,
            _down :: [Lib.Line a]}
2f4df898c4c0464346eb0a501aa024be
  data Line a = Line {_left :: [a], _center :: a, _right :: [a]}
a70045846a0bfd0fe034454186b177a8
  class M2M (m1 :: * -> *) (m2 :: * -> *) where
    (>>=>=) :: m1 a -> (a -> m2 a) -> m2 a
    {-# MINIMAL (>>=>=) #-}
6b4115b92802191b7bdce7a8072a082e
  data Nucleobase = A | U | G | C
a507435bbb1291d2b58fe6be4899ccaa
  data Nucleotide
    = Nucleotide {_base :: Lib.Nucleobase,
                  _bond3 :: GHC.Base.Maybe Lib.Direction,
                  _bond5 :: GHC.Base.Maybe Lib.Direction,
                  _hbond :: GHC.Base.Maybe Lib.Direction}
4a9c7ca0e6d5570d7f99df44756c8ea1
  _base :: Lib.Nucleotide -> Lib.Nucleobase
  RecSel Left Lib.Nucleotide
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Nucleotide) ->
                 case ds of wild { Lib.Nucleotide ds1 ds2 ds3 ds4 -> ds1 }) -}
f0f4c0f58f223be0d5e54d06abc779cf
  _bond3 :: Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction
  RecSel Left Lib.Nucleotide
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Nucleotide) ->
                 case ds of wild { Lib.Nucleotide ds1 ds2 ds3 ds4 -> ds2 }) -}
c52671533d02a3ec780544e6cf1399f8
  _bond5 :: Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction
  RecSel Left Lib.Nucleotide
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Nucleotide) ->
                 case ds of wild { Lib.Nucleotide ds1 ds2 ds3 ds4 -> ds3 }) -}
e732b12caf51788141f618be10ee5a9e
  _center :: Lib.Line a -> a
  RecSel Left Lib.Line
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line ds1 ds2 ds3 -> ds2 }) -}
950794fd5c7a79f5676ad217ef890932
  _down :: Lib.Grid a -> [Lib.Line a]
  RecSel Left Lib.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 ds2 ds3 -> ds3 }) -}
5066793f22b34e02169ce51e9df77e2a
  _hbond :: Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction
  RecSel Left Lib.Nucleotide
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Nucleotide) ->
                 case ds of wild { Lib.Nucleotide ds1 ds2 ds3 ds4 -> ds4 }) -}
2c36e765392aa943c8f0b2a621119fb5
  _left :: Lib.Line a -> [a]
  RecSel Left Lib.Line
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line ds1 ds2 ds3 -> ds1 }) -}
d19c7011402d68c087251c428cf0a44c
  _mid :: Lib.Grid a -> Lib.Line a
  RecSel Left Lib.Grid
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(A,1*U(U,U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 ds2 ds3 -> ds2 }) -}
b097456f177b7a7bb80f65890eff43a8
  _right :: Lib.Line a -> [a]
  RecSel Left Lib.Line
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line ds1 ds2 ds3 -> ds3 }) -}
0ac25aca6d8a743dec5c3f40daf9d325
  _up :: Lib.Grid a -> [Lib.Line a]
  RecSel Left Lib.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 ds2 ds3 -> ds1 }) -}
723ca252f067feab7678468f80d09819
  appendToLine :: Lib.Line a -> a -> Lib.Line a
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LLS),1*U(U,U,U)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lib.Line a) (w1 :: a) ->
                 case w of ww { Lib.Line ww1 ww2 ww3 ->
                 case Lib.$wappendToLine
                        @ a
                        ww1
                        ww2
                        ww3
                        w1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 Lib.Line @ a ww5 ww6 ww7 } }) -}
f062b8b641894a827f752690a00f9edf
  biggersnd :: GHC.Classes.Ord b => (a, b) -> (a, b) -> (a, b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLC(C(S))LLL),1*U(A,A,A,A,1*C1(C1(U)),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   ($dOrd :: GHC.Classes.Ord b)
                   (n :: (a, b))
                   (m :: (a, b)) ->
                 case n of wild { (,) ds x2 ->
                 case m of wild1 { (,) ds1 y ->
                 case GHC.Classes.> @ b $dOrd x2 y of wild2 {
                   GHC.Types.False -> wild1 GHC.Types.True -> wild } } }) -}
91e4a6c8e1f5795d4afbe6d1424b9723
  biggersndM ::
    GHC.Classes.Ord b =>
    GHC.Base.Maybe (a, b)
    -> GHC.Base.Maybe (a, b) -> GHC.Base.Maybe (a, b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,1*C1(C1(U)),A,A,A)><S,U><S,U>,
     Unfolding: (\ @ b
                   @ a
                   ($dOrd :: GHC.Classes.Ord b)
                   (ds :: GHC.Base.Maybe (a, b))
                   (ds1 :: GHC.Base.Maybe (a, b)) ->
                 let {
                   fail :: GHC.Prim.Void# -> GHC.Base.Maybe (a, b)
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     case ds1 of wild {
                       GHC.Base.Nothing -> ds
                       GHC.Base.Just ipv
                       -> case ds of wild1 {
                            GHC.Base.Nothing -> wild
                            GHC.Base.Just ipv1
                            -> GHC.Base.Just
                                 @ (a, b)
                                 (Lib.biggersnd @ b @ a $dOrd ipv1 ipv) } }
                 } in
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ (a, b)
                        GHC.Base.Just ipv -> fail GHC.Prim.void# }
                   GHC.Base.Just ipv -> fail GHC.Prim.void# }) -}
3810d9706ff3523cee7df6829f07f647
  biggersnd_$sbiggersnd ::
    (a, GHC.Types.Int) -> (a, GHC.Types.Int) -> (a, GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(U,U(U))><S(LS(S)),1*U(U,U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (n :: (a, GHC.Types.Int)) (m :: (a, GHC.Types.Int)) ->
                 case n of wild { (,) ds x2 ->
                 case m of wild1 { (,) ds1 y ->
                 case x2 of wild2 { GHC.Types.I# x3 ->
                 case y of wild3 { GHC.Types.I# y1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x3 y1) of wild4 {
                   GHC.Types.False -> wild1 GHC.Types.True -> wild } } } } }) -}
962b90cf3918800b2693cb29f3a14f3a
  changeCent :: a -> Lib.Grid a -> Lib.Grid a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(U,1*U(U,A,U),U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x2 :: a) (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid u c d ->
                 Lib.Grid
                   @ a
                   u
                   (case c of wild1 { Lib.Line l ds1 r -> Lib.Line @ a l x2 r })
                   d }) -}
64a29d8c400f9a2d80d7f727d44f8632
  changeMid :: a -> Lib.Line a -> Lib.Line a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (i :: a) (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line l ds1 r -> Lib.Line @ a l i r }) -}
241ded341b61e59bbf772c6488bb9c20
  checkColl ::
    Lib.Grid (GHC.Base.Maybe a) -> [GHC.Base.Maybe Lib.Direction]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(1*U,1*U(1*U,A,1*U),1*U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid (GHC.Base.Maybe a)) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 case Lib.$wcheckColl @ a ww1 ww5 ww7 ww3 of ww8 { (#,#) ww9 ww10 ->
                 GHC.Types.: @ (GHC.Base.Maybe Lib.Direction) ww9 ww10 } } }) -}
8a59ac87ec664aaa3104d09872639eb1
  checkColl1 :: GHC.Base.Maybe Lib.Direction
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Direction Lib.Right) -}
e0318e8b16a30a4c027731b40559cd9f
  checkColl2 :: GHC.Base.Maybe Lib.Direction
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Direction Lib.Left) -}
48de11190d030ee46a018da40bccc5fa
  checkColl3 :: GHC.Base.Maybe Lib.Direction
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Direction Lib.Down) -}
6c29749e74f68e2096c223d8b232705d
  checkColl4 :: GHC.Base.Maybe Lib.Direction
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Direction Lib.Up) -}
6f6a1e0b3d63e21df311d288385fbaf7
  compre ::
    GHC.Base.Maybe
      (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
    -> GHC.Base.Maybe
         (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
    -> GHC.Base.Maybe
         (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (x2 :: GHC.Base.Maybe
                            (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))))
                   (y :: GHC.Base.Maybe
                           (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))) ->
                 let {
                   ds :: GHC.Base.Maybe (Lib.Direction, GHC.Types.Int)
                   = case x2 of wild {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing @ (Lib.Direction, GHC.Types.Int)
                       GHC.Base.Just x3 -> Lib.molDir x3 }
                 } in
                 let {
                   ds1 :: GHC.Base.Maybe (Lib.Direction, GHC.Types.Int)
                   = case y of wild {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing @ (Lib.Direction, GHC.Types.Int)
                       GHC.Base.Just x3 -> Lib.molDir x3 }
                 } in
                 let {
                   fail :: GHC.Prim.Void#
                           -> GHC.Base.Maybe
                                (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (ds2 :: GHC.Prim.Void#)[OneShot] ->
                     case ds1 of wild {
                       GHC.Base.Nothing -> x2
                       GHC.Base.Just ipv
                       -> case ds of wild1 {
                            GHC.Base.Nothing -> y
                            GHC.Base.Just ipv1
                            -> case ipv1 of wild2 { (,) ds3 x3 ->
                               case ipv of wild3 { (,) ds4 y1 ->
                               case x3 of wild4 { GHC.Types.I# x4 ->
                               case y1 of wild5 { GHC.Types.I# y2 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x4 y2) of wild6 {
                                 GHC.Types.False
                                 -> case ds4 of wild7 {
                                      Lib.Up
                                      -> case ds3 of wild8 {
                                           DEFAULT -> y
                                           Lib.Up
                                           -> case GHC.Prim.tagToEnum#
                                                     @ GHC.Types.Bool
                                                     (GHC.Prim.==# y2 x4) of wild9 {
                                                GHC.Types.False -> y GHC.Types.True -> x2 } }
                                      Lib.Down
                                      -> case ds3 of wild8 {
                                           DEFAULT -> y
                                           Lib.Down
                                           -> case GHC.Prim.tagToEnum#
                                                     @ GHC.Types.Bool
                                                     (GHC.Prim.==# y2 x4) of wild9 {
                                                GHC.Types.False -> y GHC.Types.True -> x2 } }
                                      Lib.Left
                                      -> case ds3 of wild8 {
                                           DEFAULT -> y
                                           Lib.Left
                                           -> case GHC.Prim.tagToEnum#
                                                     @ GHC.Types.Bool
                                                     (GHC.Prim.==# y2 x4) of wild9 {
                                                GHC.Types.False -> y GHC.Types.True -> x2 } }
                                      Lib.Right
                                      -> case ds3 of wild8 {
                                           DEFAULT -> y
                                           Lib.Right
                                           -> case GHC.Prim.tagToEnum#
                                                     @ GHC.Types.Bool
                                                     (GHC.Prim.==# y2 x4) of wild9 {
                                                GHC.Types.False -> y GHC.Types.True -> x2 } } }
                                 GHC.Types.True -> case ds3 of wild7 { DEFAULT -> x2 } } } } } } } }
                 } in
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                        GHC.Base.Just ipv -> fail GHC.Prim.void# }
                   GHC.Base.Just ipv -> fail GHC.Prim.void# }) -}
ca5b91bb0d415af148ff80fca9f8d0ff
  conwayUpdate :: Lib.Grid Lib.Cell -> Lib.Cell
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SS(LSL)L),1*U(U,U(U,1*U,U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Grid Lib.Cell) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wconwayUpdate ww1 ww5 ww6 ww7 ww3 } }) -}
6a2d71c8b8b35aa0a59cf428c8bc3cab
  countAll :: GHC.Classes.Eq a => [a] -> [(a, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U,A)><S,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: [a]) ->
                 GHC.Base.map
                   @ a
                   @ (a, GHC.Types.Int)
                   (let {
                      g :: a -> a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq
                    } in
                    \ (eta1 :: a) ->
                    (eta1,
                     let {
                       p :: a -> GHC.Types.Bool = g eta1
                     } in
                     letrec {
                       $wgo1 :: [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
                         {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                       = \ (w :: [a]) (ww :: GHC.Prim.Int#) ->
                         case w of wild {
                           [] -> ww
                           : y ys
                           -> case p y of wild1 {
                                GHC.Types.False -> $wgo1 ys ww
                                GHC.Types.True -> $wgo1 ys (GHC.Prim.+# ww 1#) } }
                     } in
                     case $wgo1 eta 0# of ww { DEFAULT -> GHC.Types.I# ww }))
                   eta) -}
0aac2b0111d6ffa693ac1e6873396763
  counts :: GHC.Classes.Eq a => a -> [a] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   g :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 letrec {
                   $wgo1 :: [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ (w :: [a]) (ww :: GHC.Prim.Int#) ->
                     case w of wild {
                       [] -> ww
                       : y ys
                       -> case g y of wild1 {
                            GHC.Types.False -> $wgo1 ys ww
                            GHC.Types.True -> $wgo1 ys (GHC.Prim.+# ww 1#) } }
                 } in
                 \ (x2 :: [a]) ->
                 case $wgo1 x2 0# of ww { DEFAULT -> GHC.Types.I# ww }) -}
1934456cf8d193c322874dd1f83156e6
  diffusion ::
    Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
    -> GHC.Types.IO
         (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
  {- Arity: 1,
     Unfolding: (\ (w :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$w$ctraverse
                   @ GHC.Types.IO
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                   GHC.Base.$fApplicativeIO
                   Lib.diffusion1
                     `cast`
                   (<GHC.Base.Maybe Lib.Nucleotide>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)>_R))
                   ww1
                   ww2
                   ww3 }) -}
e623e9d28211fa4633843833cb70524a
  diffusion1 ::
    GHC.Base.Maybe Lib.Nucleotide
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction) #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: (\ (g :: GHC.Base.Maybe Lib.Nucleotide)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, GHC.Types.Float)
                        @ GHC.Types.Float
                        r#
                        System.Random.$fRandomFloat2
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { GHC.Types.F# ipv2 ->
                 (# ipv,
                    case g of wild1 {
                      GHC.Base.Nothing
                      -> GHC.Base.Nothing @ (Lib.Nucleotide, Lib.Direction)
                      GHC.Base.Just x2
                      -> GHC.Base.Just
                           @ (Lib.Nucleotide, Lib.Direction)
                           (x2,
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.ltFloat# ipv2 0.25#) of wild2 {
                              GHC.Types.False
                              -> case GHC.Prim.tagToEnum#
                                        @ GHC.Types.Bool
                                        (GHC.Prim.ltFloat# ipv2 0.5#) of wild3 {
                                   GHC.Types.False
                                   -> case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.ltFloat# ipv2 0.75#) of wild4 {
                                        GHC.Types.False
                                        -> case GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.ltFloat# ipv2 1.0#) of wild5 {
                                             GHC.Types.False -> Lib.Left
                                             GHC.Types.True -> Lib.Down }
                                        GHC.Types.True -> Lib.Up }
                                   GHC.Types.True -> Lib.Right }
                              GHC.Types.True -> Lib.Left }) } #) } } }) -}
3fead3450e12d98ebfebd75d61e1b1eb
  dirs :: [Lib.Direction]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Lib.Direction Lib.Up Lib.dirs1) -}
345e7022f6d2b4df283cd3a97e689132
  dirs1 :: [Lib.Direction]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Lib.Direction Lib.Down Lib.dirs2) -}
ec447367954616e73cbb888676047d7a
  dirs2 :: [Lib.Direction]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Lib.Direction Lib.Left Lib.dirs3) -}
e20b3eefe34df6002bdff7f365394c44
  dirs3 :: [Lib.Direction]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Direction
                   Lib.Right
                   (GHC.Types.[] @ Lib.Direction)) -}
9bc2666f443cf9e5365f7eeadc161c16
  emptyNLine :: Lib.Line (GHC.Base.Maybe a)
  {- Strictness: m,
     Unfolding: (\ @ a ->
                 Lib.Line
                   @ (GHC.Base.Maybe a)
                   (Lib.emptyNLine2 @ a)
                   (GHC.Base.Nothing @ a)
                   (Lib.emptyNLine1 @ a)) -}
d75786b2b16421d8e1e687769818cf50
  emptyNLine1 :: [GHC.Base.Maybe a]
  {- Unfolding: (\ @ a ->
                 case Lib.$wxs @ a 22# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Base.Maybe a) ww1 ww2 }) -}
029bb9928d9356916cb3ee85c40ff764
  emptyNLine2 :: [GHC.Base.Maybe a]
  {- Unfolding: (\ @ a ->
                 case Lib.$wxs1 @ a 10# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Base.Maybe a) ww1 ww2 }) -}
aa31a58261d4721d26a1eb2ced815817
  fl2dir :: GHC.Types.Float -> Lib.Direction
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Float) ->
                 case w of ww { GHC.Types.F# ww1 -> Lib.$wfl2dir ww1 }) -}
97e610ce435ee1b9acdb866559c18234
  gridConfigurations :: Lib.Grid a -> Lib.Grid (Lib.Grid a)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U(U,U,U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case Lib.$wgridConfigurations
                        @ a
                        ww1
                        ww2
                        ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 Lib.Grid @ (Lib.Grid a) ww5 ww6 ww7 } }) -}
638b65db4af74f379e04ff6a75c34dfc
  height :: Lib.Grid a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLS),1*U(1*U,A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case GHC.List.$wlenAcc @ (Lib.Line a) ww1 0# of ww4 { DEFAULT ->
                 case GHC.List.$wlenAcc @ (Lib.Line a) ww3 0# of ww5 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.+# (GHC.Prim.+# ww4 ww5) 1#) } } }) -}
63fec1003de9a26604fb772c9b515845
  horizNeighb :: Lib.Grid a -> [a]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SLS)L),1*U(A,1*U(1*U,A,1*U),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$whorizNeighb @ a ww5 ww7 } }) -}
97e610ce435ee1b9acdb866559c18234
  horizontalConfigurations :: Lib.Grid a -> Lib.Line (Lib.Grid a)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(U,U(U,U,U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 case Lib.$whorizontalConfigurations
                        @ a
                        ww1
                        ww5
                        ww6
                        ww7
                        ww3 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Lib.Line @ (Lib.Grid a) ww9 ww10 ww11 } } }) -}
e4db9d040a0cfd28fa6d0d587a8e3d09
  inv :: Lib.Direction -> Lib.Direction
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Direction) ->
                 case ds of wild {
                   Lib.Up -> Lib.Down
                   Lib.Down -> Lib.Up
                   Lib.Left -> Lib.Right
                   Lib.Right -> Lib.Left }) -}
984e2cdd2ebc75f32605c98ba96ef6ec
  limap :: (Lib.Line a -> Lib.Line a) -> Lib.Grid a -> Lib.Grid a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lib.Line a -> Lib.Line a) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.Grid
                   @ a
                   (GHC.Base.map @ (Lib.Line a) @ (Lib.Line a) w ww1)
                   (w ww2)
                   (GHC.Base.map @ (Lib.Line a) @ (Lib.Line a) w ww3) }) -}
af5250ee248ce91f548b5be5c19e0869
  listPart ::
    (a -> GHC.Base.Maybe Lib.Direction)
    -> (a -> GHC.Base.Maybe Lib.Direction)
    -> Lib.Grid (GHC.Base.Maybe a)
    -> [Lib.Grid (GHC.Base.Maybe a)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><L,C(U)><S(LS(LSL)L),1*U(U,U(U,U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: a -> GHC.Base.Maybe Lib.Direction)
                   (w1 :: a -> GHC.Base.Maybe Lib.Direction)
                   (w2 :: Lib.Grid (GHC.Base.Maybe a)) ->
                 case w2 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wlistPart @ a w w1 ww1 ww5 ww6 ww7 ww3 } }) -}
622d54c47f4b6156aa64457d1f9048db
  listPartMol ::
    Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
    -> [Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),1*U(U,U(U,U,U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wlistPartMol ww1 ww5 ww6 ww7 ww3 } }) -}
58b62a993b98285128e845b15e10a96a
  listPartMolD ::
    (a -> GHC.Base.Maybe Lib.Direction)
    -> Lib.Grid (GHC.Base.Maybe a) -> [Lib.Grid (GHC.Base.Maybe a)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S(LS(LSL)L),1*U(U,U(U,U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> GHC.Base.Maybe Lib.Direction)
                   (w1 :: Lib.Grid (GHC.Base.Maybe a)) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wlistPartMolD @ a w ww1 ww5 ww6 ww7 ww3 } }) -}
6fa887452e008d4c0d45e8ad956db45b
  listPartTup ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, b))
    -> [Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, b))]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),1*U(U,U(U,U,U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ b (w :: Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, b))) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wlistPartTup @ b ww1 ww5 ww6 ww7 ww3 } }) -}
2c753e3f8296d78ecd21443b6431fb33
  lowerNeighb :: Lib.Grid a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$wlowerNeighb @ a ww3 }) -}
9336c0bb4753fdf6b6053847467cc7f2
  mToList :: GHC.Base.Maybe a -> (a -> [b]) -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ds :: GHC.Base.Maybe a) (ds1 :: a -> [b]) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ b
                   GHC.Base.Just a1 -> ds1 a1 }) -}
4c5538c0696a4afcf73f4cbae2123869
  molDir ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> GHC.Base.Maybe (Lib.Direction, GHC.Types.Int)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),U(U,U(U,U,U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Grid
                           (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wmolDir ww1 ww5 ww6 ww7 ww3 } }) -}
8326b36d54f550aa1c8db13fd30f0c77
  molDir1 ::
    [Lib.Direction] -> Lib.Direction -> (Lib.Direction, GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [Lib.Direction]) (w1 :: Lib.Direction) ->
                 case Lib.$wlvl w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
3b7c4ca512c29d47c99620ef8b4ecbfe
  molDir2 ::
    (Lib.Direction, GHC.Types.Int)
    -> (Lib.Direction, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (w2 :: (Lib.Direction, GHC.Types.Int))
                   (w3 :: (Lib.Direction, GHC.Types.Int))[OneShot] ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case w3 of ww3 { (,) ww4 ww5 ->
                 case Lib.$fOrdDirection_$ccompare ww1 ww4 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ -> GHC.Classes.compareInt ww2 ww5
                   GHC.Types.GT -> GHC.Types.GT } } }) -}
4d8d236cab9e15408547a84dee6202ad
  molDir3 ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> GHC.Base.Maybe Lib.Direction
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),1*U(A,1*U(A,1*U,A),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: Lib.Grid
                            (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case x2 of wild { Lib.Grid ds ds1 ds2 ->
                 case ds1 of wild1 { Lib.Line ds3 x3 ds4 ->
                 case x3 of wild2 {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ Lib.Direction
                   GHC.Base.Just x4
                   -> GHC.Base.Just
                        @ Lib.Direction
                        (Data.Tuple.snd @ Lib.Nucleotide @ Lib.Direction x4) } } }) -}
9299d22ff39ba3cbb66a92dc287c1308
  mooresNeighb :: Lib.Grid a -> [a]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLL),U(1*U,1*U(1*U,A,1*U),1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$wmooresNeighb @ a ww1 ww2 ww3 }) -}
97e610ce435ee1b9acdb866559c18234
  moveDownGrid :: Lib.Grid a -> Lib.Grid a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid up x2 ds1 ->
                 case ds1 of wild1 {
                   [] -> wild
                   : y down
                   -> Lib.Grid @ a (GHC.Types.: @ (Lib.Line a) x2 up) y down } }) -}
bac26d127ccdaf11524808fc1879a962
  moveGrid :: Lib.Direction -> Lib.Grid a -> Lib.Grid a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><S,1*U(U,U(U,U,U),U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lib.Direction) (w1 :: Lib.Grid a) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case w of wild {
                   Lib.Up
                   -> case ww1 of wild1 {
                        [] -> Lib.Grid @ a (GHC.Types.[] @ (Lib.Line a)) ww2 ww3
                        : y up -> Lib.Grid @ a up y (GHC.Types.: @ (Lib.Line a) ww2 ww3) }
                   Lib.Down
                   -> case ww3 of wild1 {
                        [] -> Lib.Grid @ a ww1 ww2 (GHC.Types.[] @ (Lib.Line a))
                        : y down
                        -> Lib.Grid @ a (GHC.Types.: @ (Lib.Line a) ww2 ww1) y down }
                   Lib.Left
                   -> Lib.Grid
                        @ a
                        (GHC.Base.map
                           @ (Lib.Line a)
                           @ (Lib.Line a)
                           (Lib.moveLeftLine @ a)
                           ww1)
                        (Lib.moveLeftLine @ a ww2)
                        (GHC.Base.map
                           @ (Lib.Line a)
                           @ (Lib.Line a)
                           (Lib.moveLeftLine @ a)
                           ww3)
                   Lib.Right
                   -> Lib.Grid
                        @ a
                        (GHC.Base.map
                           @ (Lib.Line a)
                           @ (Lib.Line a)
                           (Lib.moveRightLine @ a)
                           ww1)
                        (Lib.moveRightLine @ a ww2)
                        (GHC.Base.map
                           @ (Lib.Line a)
                           @ (Lib.Line a)
                           (Lib.moveRightLine @ a)
                           ww3) } }) -}
97e610ce435ee1b9acdb866559c18234
  moveLeftGrid :: Lib.Grid a -> Lib.Grid a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U(U,U,U),1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.Grid
                   @ a
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line a)
                      (Lib.moveLeftLine @ a)
                      ww1)
                   (Lib.moveLeftLine @ a ww2)
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line a)
                      (Lib.moveLeftLine @ a)
                      ww3) }) -}
a7203f3d06331da544628606d948577e
  moveLeftLine :: Lib.Line a -> Lib.Line a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line ds1 x2 right ->
                 case ds1 of wild1 {
                   [] -> wild
                   : l left -> Lib.Line @ a left l (GHC.Types.: @ a x2 right) } }) -}
97e610ce435ee1b9acdb866559c18234
  moveRightGrid :: Lib.Grid a -> Lib.Grid a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U(U,U,U),1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.Grid
                   @ a
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line a)
                      (Lib.moveRightLine @ a)
                      ww1)
                   (Lib.moveRightLine @ a ww2)
                   (GHC.Base.map
                      @ (Lib.Line a)
                      @ (Lib.Line a)
                      (Lib.moveRightLine @ a)
                      ww3) }) -}
6d094919178ecd17bc2accc588e4cb0a
  moveRightLine :: Lib.Line a -> Lib.Line a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Line a) ->
                 case ds of wild { Lib.Line left x2 ds1 ->
                 case ds1 of wild1 {
                   [] -> wild
                   : r right -> Lib.Line @ a (GHC.Types.: @ a x2 left) r right } }) -}
97e610ce435ee1b9acdb866559c18234
  moveUpGrid :: Lib.Grid a -> Lib.Grid a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 x2 down ->
                 case ds1 of wild1 {
                   [] -> wild
                   : y up
                   -> Lib.Grid @ a up y (GHC.Types.: @ (Lib.Line a) x2 down) } }) -}
2a3489dcfcae4ca744333af7a95ba51c
  neuConfs ::
    GHC.Classes.Eq a => Lib.Grid a -> [(Lib.Direction, Lib.Grid a)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(U,U(U,U,U),U)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (g :: Lib.Grid a) ->
                 let {
                   lvl31 :: Lib.Grid a -> Lib.Grid a -> GHC.Types.Bool
                   = Lib.$fEqGrid_$c== @ a $dEq
                 } in
                 letrec {
                   go1 :: [Lib.Direction] -> [(Lib.Direction, Lib.Grid a)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lib.Direction]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (Lib.Direction, Lib.Grid a)
                       : y ys
                       -> let {
                            x2 :: Lib.Grid a
                            = case g of ww { Lib.Grid ww1 ww2 ww3 ->
                              case y of wild1 {
                                Lib.Up
                                -> case ww1 of wild2 {
                                     [] -> Lib.Grid @ a (GHC.Types.[] @ (Lib.Line a)) ww2 ww3
                                     : y1 up
                                     -> Lib.Grid @ a up y1 (GHC.Types.: @ (Lib.Line a) ww2 ww3) }
                                Lib.Down
                                -> case ww3 of wild2 {
                                     [] -> Lib.Grid @ a ww1 ww2 (GHC.Types.[] @ (Lib.Line a))
                                     : y1 down
                                     -> Lib.Grid @ a (GHC.Types.: @ (Lib.Line a) ww2 ww1) y1 down }
                                Lib.Left
                                -> Lib.Grid
                                     @ a
                                     (GHC.Base.map
                                        @ (Lib.Line a)
                                        @ (Lib.Line a)
                                        (Lib.moveLeftLine @ a)
                                        ww1)
                                     (Lib.moveLeftLine @ a ww2)
                                     (GHC.Base.map
                                        @ (Lib.Line a)
                                        @ (Lib.Line a)
                                        (Lib.moveLeftLine @ a)
                                        ww3)
                                Lib.Right
                                -> Lib.Grid
                                     @ a
                                     (GHC.Base.map
                                        @ (Lib.Line a)
                                        @ (Lib.Line a)
                                        (Lib.moveRightLine @ a)
                                        ww1)
                                     (Lib.moveRightLine @ a ww2)
                                     (GHC.Base.map
                                        @ (Lib.Line a)
                                        @ (Lib.Line a)
                                        (Lib.moveRightLine @ a)
                                        ww3) } }
                          } in
                          case lvl31 x2 g of wild1 {
                            GHC.Types.False
                            -> GHC.Types.: @ (Lib.Direction, Lib.Grid a) (y, x2) (go1 ys)
                            GHC.Types.True -> go1 ys } }
                 } in
                 go1 Lib.dirs) -}
aa4abb4f5f85915355cc5ecdcae3144b
  neuConfs_$sneuConfs ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [(Lib.Direction,
         Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))]
  {- Arity: 1, Strictness: <L,U(U,U(U,U,U),U)> -}
227fd980579014c6b0233cb0185e51ed
  neuNeigh :: Lib.Grid a -> [(Lib.Direction, a)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(1*U,1*U(1*U,A,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wneuNeigh @ a ww1 ww5 ww7 ww3 } }) -}
fadcbf2601e825681cd859cc7fd89e75
  nucNeighb ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Direction]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LSL)L),1*U(U,U(U,U,U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Grid
                           (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wnucNeighb ww1 ww5 ww6 ww7 ww3 } }) -}
b79cd2e8dbe08de447e2cdf3378bcba0
  nucNeighbN ::
    (Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction)
    -> Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> [Lib.Direction]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S(LS(LSL)L),1*U(U,U(U,U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Nucleotide -> GHC.Base.Maybe Lib.Direction)
                   (w1 :: Lib.Grid
                            (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case w1 of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wnucNeighbN w ww1 ww5 ww6 ww7 ww3 } }) -}
cb1f6dd0c3b6b522f9b2de57b88d1247
  sampleGrid :: Lib.Grid Lib.Cell
  {- Strictness: m,
     Unfolding: (Lib.Grid
                   @ Lib.Cell
                   Lib.sampleGrid_u
                   Lib.sampleLine
                   Lib.sampleGrid_d) -}
a6e494b57b5bb899eb39613b75d99660
  sampleGrid_d :: [Lib.Line Lib.Cell]
  {- Unfolding: (case Lib.$wxs2 38# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (Lib.Line Lib.Cell) ww1 ww2 }) -}
0fed98a51a60c01ba4620c901259a927
  sampleGrid_u :: [Lib.Line Lib.Cell]
  {- Unfolding: (case Lib.$wxs5 38# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (Lib.Line Lib.Cell) ww1 ww2 }) -}
96a65516aea7dfc011f55813dded2976
  sampleLine :: Lib.Line Lib.Cell
  {- Strictness: m,
     Unfolding: (Lib.Line
                   @ Lib.Cell
                   Lib.sampleLine2
                   Lib.Dead
                   Lib.sampleLine1) -}
c0531fcc30eacdb30cc7695f6a41bc47
  sampleLine1 :: [Lib.Cell]
  {- Unfolding: (Lib.$wxs3 34#) -}
107c3439436082eefc482b9cefc56068
  sampleLine2 :: [Lib.Cell]
  {- Unfolding: (Lib.$wxs4 34#) -}
df49c32d90ebf53fcb4ee781da89c2a0
  sampleNGrid :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
  {- Strictness: m,
     Unfolding: (Lib.Grid
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNGrid4
                   Lib.sampleNLine
                   Lib.sampleNGrid1) -}
d4e61a2f67dfca4babfcb736e4cf72fd
  sampleNGrid1 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   Lib.sampleNLine
                   Lib.sampleNGrid3) -}
7c0ed2e0aa4e591d06eb498b2bdc18a9
  sampleNGrid2 :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
  {- Strictness: m,
     Unfolding: (Lib.Grid
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNGrid8
                   (Lib.emptyNLine @ Lib.Nucleotide)
                   Lib.sampleNGrid6) -}
1643936633766fa39ce4ac0373922895
  sampleNGrid3 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Unfolding: (case Lib.$wxs6 20# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   ww1
                   ww2 }) -}
d62be7e5504716cba729ad5e3ce0e2bd
  sampleNGrid4 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   Lib.sampleNLine
                   Lib.sampleNGrid5) -}
9c4aecd23755c8bddf9665c3b34984f5
  sampleNGrid5 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Unfolding: (case Lib.$wxs9 20# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   ww1
                   ww2 }) -}
10298da6efe8d21577ca80a0a8179cbc
  sampleNGrid6 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   Lib.sampleNLine
                   Lib.sampleNGrid7) -}
60092ea5ec73de611108d336d1ea9c3c
  sampleNGrid7 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Unfolding: (case Lib.$wxs10 20# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   ww1
                   ww2 }) -}
6454dd75353ef717b01509ee899f94ba
  sampleNGrid8 :: [Lib.Line (GHC.Base.Maybe Lib.Nucleotide)]
  {- Unfolding: (case Lib.$wxs11 20# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ (Lib.Line (GHC.Base.Maybe Lib.Nucleotide))
                   ww1
                   ww2 }) -}
4b5670d6019007fb0e1c6299ac3047bd
  sampleNLine :: Lib.Line (GHC.Base.Maybe Lib.Nucleotide)
  {- Strictness: m,
     Unfolding: (Lib.Line
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine23
                   (GHC.Base.Nothing @ Lib.Nucleotide)
                   Lib.sampleNLine1) -}
16fc0921af6bfeccff52077d76c49649
  sampleNLine1 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine21
                   Lib.sampleNLine2) -}
86c563d223b47c7801b041626a116860
  sampleNLine10 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Unfolding: (case Lib.$wxs7 13# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Base.Maybe Lib.Nucleotide) ww1 ww2 }) -}
a4d730907a6a742e91394d74080028ac
  sampleNLine11 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine12) -}
558de293d2346a35150590d767f6ff88
  sampleNLine12 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.G
                   Lib.checkColl2
                   (GHC.Base.Nothing @ Lib.Direction)
                   (GHC.Base.Nothing @ Lib.Direction)) -}
e66fce371b8c07d9879574637604ba19
  sampleNLine13 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine14) -}
fa5520838648e01714a913618af26cd3
  sampleNLine14 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.G
                   Lib.checkColl2
                   Lib.checkColl1
                   (GHC.Base.Nothing @ Lib.Direction)) -}
edba820f03db529b237a409a8abbebdb
  sampleNLine15 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine16) -}
331ad73319e6d5a33ee587c97036af97
  sampleNLine16 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.C
                   Lib.checkColl2
                   Lib.checkColl1
                   (GHC.Base.Nothing @ Lib.Direction)) -}
c11d4027a7f125b0a7497ce98045b9fa
  sampleNLine17 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine18) -}
960d2508edc3d7f97f921454359b477b
  sampleNLine18 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.U
                   Lib.checkColl2
                   Lib.checkColl1
                   (GHC.Base.Nothing @ Lib.Direction)) -}
3d6a8fd69e42ffa276307eb9ae1ac4e9
  sampleNLine19 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine20) -}
f0e9ca75eff61dd28f6d7b419fbd9d5f
  sampleNLine2 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine19
                   Lib.sampleNLine3) -}
4ab9ec35bc8f4184a6c498386a36b675
  sampleNLine20 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.A
                   Lib.checkColl2
                   Lib.checkColl1
                   (GHC.Base.Nothing @ Lib.Direction)) -}
43e6eaf5f475a6844f9b0cda609bf6d8
  sampleNLine21 :: GHC.Base.Maybe Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ Lib.Nucleotide Lib.sampleNLine22) -}
b4d341a215738169a59cca43d20ab951
  sampleNLine22 :: Lib.Nucleotide
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Nucleotide
                   Lib.G
                   (GHC.Base.Nothing @ Lib.Direction)
                   Lib.checkColl1
                   (GHC.Base.Nothing @ Lib.Direction)) -}
2ff4d42e3925b4e723fc1b1dce05ebec
  sampleNLine23 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Unfolding: (case Lib.$wxs8 10# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (GHC.Base.Maybe Lib.Nucleotide) ww1 ww2 }) -}
adda33ce2990f288efd5c0f59d23e4ce
  sampleNLine3 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine15
                   Lib.sampleNLine4) -}
b0036182c62f8aba1d756bc997386538
  sampleNLine4 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine19
                   Lib.sampleNLine5) -}
31eb8eb267943fbf59d1b98bee391501
  sampleNLine5 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine17
                   Lib.sampleNLine6) -}
f10d76d3486a3e83db838f6e41bd293f
  sampleNLine6 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine15
                   Lib.sampleNLine7) -}
52a05f613b7677bf3b0234f7cbe9caa2
  sampleNLine7 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine13
                   Lib.sampleNLine8) -}
1d81ced36a9a43eb689a9fb6994f8a06
  sampleNLine8 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   Lib.sampleNLine11
                   Lib.sampleNLine9) -}
548ba0b057755eb5005f0d589b4ae7df
  sampleNLine9 :: [GHC.Base.Maybe Lib.Nucleotide]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.Maybe Lib.Nucleotide)
                   (GHC.Base.Nothing @ Lib.Nucleotide)
                   Lib.sampleNLine10) -}
f5c84dfe05b577b4c87b36817b34928b
  simulationGOF :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.simulationGOF1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
2f95b25022d5703f67b71bc06a03b5c2
  simulationGOF1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 case Graphics.Gloss.Internals.Interface.Simulate.simulateWithBackendIO1
                        @ (Lib.Grid Lib.Cell)
                        @ Graphics.Gloss.Internals.Interface.Backend.GLUT.GLUTState
                        Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState
                        Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState_$cinitBackendState
                        Lib.simulationGOF6
                        Graphics.Gloss.Data.Color.white
                        Lib.simulationGOF5
                        Lib.sampleGrid
                        Lib.simulationGOF4
                          `cast`
                        (<Lib.Grid Lib.Cell>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Graphics.Gloss.Internals.Data.Picture.Picture>_R))
                        Lib.simulationGOF2
                          `cast`
                        (<Graphics.Gloss.Data.ViewPort.ViewPort>_R
                         ->_R <GHC.Types.Float>_R
                         ->_R <Lib.Grid Lib.Cell>_R
                         ->_R Sym (GHC.Types.N:IO[0] <Lib.Grid Lib.Cell>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
7ebf0cfda0ec678df81eac0f31f884c8
  simulationGOF10 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 1366#) -}
84e76508694c50261e5e1ddb41594f5b
  simulationGOF11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Conway"#) -}
b97d62b047bfd3545338d3aca0862650
  simulationGOF2 ::
    Graphics.Gloss.Data.ViewPort.ViewPort
    -> GHC.Types.Float
    -> Lib.Grid Lib.Cell
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Lib.Grid Lib.Cell #)
  {- Arity: 4, HasNoCafRefs,
     Unfolding: (\ (view :: Graphics.Gloss.Data.ViewPort.ViewPort)
                   (time :: GHC.Types.Float)[OneShot]
                   (model1 :: Lib.Grid Lib.Cell)[OneShot]
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s,
                    case model1 of ww { Lib.Grid ww1 ww2 ww3 ->
                    case Lib.$wgridConfigurations
                           @ Lib.Cell
                           ww1
                           ww2
                           ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                    Lib.Grid
                      @ Lib.Cell
                      (GHC.Base.map
                         @ (Lib.Line (Lib.Grid Lib.Cell))
                         @ (Lib.Line Lib.Cell)
                         Lib.simulationGOF3
                         ww5)
                      (case ww6 of ww8 { Lib.Line ww9 ww10 ww11 ->
                       Lib.Line
                         @ Lib.Cell
                         (GHC.Base.map
                            @ (Lib.Grid Lib.Cell)
                            @ Lib.Cell
                            Lib.conwayUpdate
                            ww9)
                         (Lib.conwayUpdate ww10)
                         (GHC.Base.map
                            @ (Lib.Grid Lib.Cell)
                            @ Lib.Cell
                            Lib.conwayUpdate
                            ww11) })
                      (GHC.Base.map
                         @ (Lib.Line (Lib.Grid Lib.Cell))
                         @ (Lib.Line Lib.Cell)
                         Lib.simulationGOF3
                         ww7) } } #)) -}
2bb85c950f15939328a375feb5a476e7
  simulationGOF3 :: Lib.Line (Lib.Grid Lib.Cell) -> Lib.Line Lib.Cell
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (w :: Lib.Line (Lib.Grid Lib.Cell)) ->
                 case w of ww { Lib.Line ww1 ww2 ww3 ->
                 Lib.Line
                   @ Lib.Cell
                   (GHC.Base.map
                      @ (Lib.Grid Lib.Cell)
                      @ Lib.Cell
                      Lib.conwayUpdate
                      ww1)
                   (Lib.conwayUpdate ww2)
                   (GHC.Base.map
                      @ (Lib.Grid Lib.Cell)
                      @ Lib.Cell
                      Lib.conwayUpdate
                      ww3) }) -}
66c346714818b49cb2ec56e6c6af75e1
  simulationGOF4 ::
    Lib.Grid Lib.Cell
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Graphics.Gloss.Internals.Data.Picture.Picture #)
  {- Arity: 2,
     Unfolding: (\ (x2 :: Lib.Grid Lib.Cell)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s,
                    case x2 of ww { Lib.Grid ww1 ww2 ww3 ->
                    case Lib.$w$cdraw
                           @ Lib.Cell
                           Lib.$fDrawableCell_$cdraw
                             `cast`
                           (Sym (Lib.N:Drawable[0] <Lib.Cell>_N))
                           ww1
                           ww2
                           ww3 of ww4 { Unit# ww5 ->
                    Graphics.Gloss.Internals.Data.Picture.Pictures ww5 } } #)) -}
fc71f2a72be8475149eca6ff1c23613a
  simulationGOF5 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 3#) -}
c6161ec26d4a3d73add6aad34bca9f1c
  simulationGOF6 :: Graphics.Gloss.Data.Display.Display
  {- Unfolding: (Graphics.Gloss.Data.Display.InWindow
                   Lib.simulationGOF11
                   Lib.simulationGOF8
                   Lib.simulationGOF7) -}
dbf04e845fcbb50a09bf9bed78524b95
  simulationGOF7 :: (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs,
     Unfolding: ((Lib.$fFoldableGrid5, Lib.$fFoldableGrid5)) -}
346433600469d8773abae5d95fa3fd0c
  simulationGOF8 :: (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs,
     Unfolding: ((Lib.simulationGOF10, Lib.simulationGOF9)) -}
fcffdab33439d94e38e2d496aabad1a2
  simulationGOF9 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 768#) -}
a03845194fa0ea6432f849b5bfb1e732
  simulationN :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.simulationN1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
81477b6b3dd91c8534ca59b5e7de45f1
  simulationN1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 case Graphics.Gloss.Internals.Interface.Simulate.simulateWithBackendIO1
                        @ (Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))
                        @ Graphics.Gloss.Internals.Interface.Backend.GLUT.GLUTState
                        Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState
                        Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState_$cinitBackendState
                        Lib.simulationN4
                        Graphics.Gloss.Data.Color.white
                        Lib.simulationGOF5
                        Lib.sampleNGrid2
                        Lib.simulationN3
                          `cast`
                        (<Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Graphics.Gloss.Internals.Data.Picture.Picture>_R))
                        Lib.simulationN2
                          `cast`
                        (<Graphics.Gloss.Data.ViewPort.ViewPort>_R
                         ->_R <GHC.Types.Float>_R
                         ->_R <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R))
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
a2b829189d079aa5f2bd90bcc3a233f4
  simulationN2 ::
    Graphics.Gloss.Data.ViewPort.ViewPort
    -> GHC.Types.Float
    -> Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Lib.Grid (GHC.Base.Maybe Lib.Nucleotide) #)
  {- Arity: 4, HasNoCafRefs,
     Unfolding: (\ (view :: Graphics.Gloss.Data.ViewPort.ViewPort)
                   (time :: GHC.Types.Float)[OneShot]
                   (model1 :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))[OneShot]
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s, model1 #)) -}
286c0c7fbc0552f6e4cbb407086b5a9f
  simulationN3 ::
    Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Graphics.Gloss.Internals.Data.Picture.Picture #)
  {- Arity: 2,
     Unfolding: (\ (x2 :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s,
                    case x2 of ww { Lib.Grid ww1 ww2 ww3 ->
                    case Lib.$w$cdraw
                           @ (GHC.Base.Maybe Lib.Nucleotide)
                           Lib.$sdraw4
                             `cast`
                           (Sym (Lib.N:Drawable[0] <GHC.Base.Maybe Lib.Nucleotide>_N))
                           ww1
                           ww2
                           ww3 of ww4 { Unit# ww5 ->
                    Graphics.Gloss.Internals.Data.Picture.Pictures ww5 } } #)) -}
1afa47629eba13266421a30e8b7cc87e
  simulationN4 :: Graphics.Gloss.Data.Display.Display
  {- Unfolding: (Graphics.Gloss.Data.Display.InWindow
                   Lib.simulationN5
                   Lib.simulationGOF8
                   Lib.simulationGOF7) -}
26321dad62fb82b401bfce21c75620d5
  simulationN5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RNA"#) -}
9d7ef71c45fc0a84c55bfcdde117c90d
  simulationNIO :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Lib.simulationNIO1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
8571d07bfcec12e2e422eee475ddf49d
  simulationNIO0 :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Lib.simulationNIO4 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
bb6fae00b836acce3ec7c8f3db87f5d6
  simulationNIO1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (Graphics.Gloss.Internals.Interface.Simulate.simulateWithBackendIO1
                   @ (Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))
                   @ Graphics.Gloss.Internals.Interface.Backend.GLUT.GLUTState
                   Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState
                   Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState_$cinitBackendState
                   Lib.simulationN4
                   Graphics.Gloss.Data.Color.white
                   Lib.simulationNIO3
                   Lib.sampleNGrid
                   Lib.simulationN3
                     `cast`
                   (<Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Graphics.Gloss.Internals.Data.Picture.Picture>_R))
                   (Lib.simulationNIO2
                      @ GHC.Types.Float
                      @ Graphics.Gloss.Data.ViewPort.ViewPort)
                     `cast`
                   (<Graphics.Gloss.Data.ViewPort.ViewPort>_R
                    ->_R <GHC.Types.Float>_R
                    ->_R <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R))) -}
e6ce9bea80d1dc49043a904e9a1a8217
  simulationNIO2 ::
    t1
    -> t
    -> Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Lib.Grid (GHC.Base.Maybe Lib.Nucleotide) #)
  {- Arity: 4,
     Strictness: <L,A><L,A><S,1*U(1*U,1*U(1*U,U,1*U),1*U)><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ t
                   @ t1
                   (ds :: t1)
                   (ds1 :: t)
                   (g :: Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (Lib.$fTraversableGrid_$ctraverse
                         @ GHC.Types.IO
                         @ (GHC.Base.Maybe Lib.Nucleotide)
                         @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                         GHC.Base.$fApplicativeIO
                         Lib.diffusion1
                           `cast`
                         (<GHC.Base.Maybe Lib.Nucleotide>_R
                          ->_R Sym (GHC.Types.N:IO[0]
                                        <GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)>_R))
                         g)
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))>_R)
                        eta of ds2 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Lib.$fComonadGrid_$cfmap
                      @ (Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction)))
                      @ (GHC.Base.Maybe Lib.Nucleotide)
                      Lib.updateNuc
                      (Lib.gridConfigurations
                         @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
                         ipv1) #) }) -}
36f13413bffa8d5199c9dc8580c7cc40
  simulationNIO3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
cd16e2321357642d5c05dfcd6c82c079
  simulationNIO4 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (Graphics.Gloss.Internals.Interface.Simulate.simulateWithBackendIO1
                   @ (Lib.Grid (GHC.Base.Maybe Lib.Nucleotide))
                   @ Graphics.Gloss.Internals.Interface.Backend.GLUT.GLUTState
                   Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState
                   Graphics.Gloss.Internals.Interface.Backend.GLUT.$fBackendGLUTState_$cinitBackendState
                   Lib.simulationN4
                   Graphics.Gloss.Data.Color.white
                   Lib.simulationNIO3
                   Lib.sampleNGrid2
                   Lib.simulationN3
                     `cast`
                   (<Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Graphics.Gloss.Internals.Data.Picture.Picture>_R))
                   (Lib.simulationNIO2
                      @ GHC.Types.Float
                      @ Graphics.Gloss.Data.ViewPort.ViewPort)
                     `cast`
                   (<Graphics.Gloss.Data.ViewPort.ViewPort>_R
                    ->_R <GHC.Types.Float>_R
                    ->_R <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R
                    ->_R Sym (GHC.Types.N:IO[0]
                                  <Lib.Grid (GHC.Base.Maybe Lib.Nucleotide)>_R))) -}
6d2dd39ea452b2c7ee8e4d78f102a988
  someFunc :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.someFunc1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
665d81d861cab3b49ac479f4d6c3a622
  someFunc1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Lib.someFunc2
                   GHC.Types.True
                   eta) -}
ccfb05de242d52fff2f506af02140320
  someFunc2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "someFunc"#) -}
33d85900f978f07d4ed1b0d25ea2074b
  updateNuc ::
    Lib.Grid (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
    -> GHC.Base.Maybe Lib.Nucleotide
  {- Arity: 1, Strictness: <S(LS(LSL)L),1*U(U,U(U,U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Grid
                           (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lib.Line ww5 ww6 ww7 ->
                 Lib.$wupdateNuc ww1 ww5 ww6 ww7 ww3 } }) -}
9710ee5ae635fb4df6dbf28be78f21b1
  upperNeighb :: Lib.Grid a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Lib.Grid a) ->
                 case w of ww { Lib.Grid ww1 ww2 ww3 ->
                 Lib.$wupperNeighb @ a ww1 }) -}
50d8886c67ef5a91c2629344cb9ea0f8
  width :: Lib.Grid a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SLL)L),1*U(A,1*U(1*U,U,1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lib.Grid a) ->
                 case ds of wild { Lib.Grid ds1 x2 ds2 ->
                 Lib.$fFoldableLine_$clength @ a x2 }) -}
instance Control.Comonad.Comonad [Lib.Grid] = Lib.$fComonadGrid
instance Lib.Drawable [Lib.Cell] = Lib.$fDrawableCell
instance Lib.Drawable [Lib.Grid] = Lib.$fDrawableGrid
instance Lib.Drawable [Lib.Line] = Lib.$fDrawableLine
instance Lib.Drawable [GHC.Base.Maybe] = Lib.$fDrawableMaybe
instance Lib.Drawable [Lib.Nucleobase] = Lib.$fDrawableNucleobase
instance Lib.Drawable [Lib.Nucleotide] = Lib.$fDrawableNucleotide
instance GHC.Classes.Eq [Lib.Cell] = Lib.$fEqCell
instance GHC.Classes.Eq [Lib.Direction] = Lib.$fEqDirection
instance GHC.Classes.Eq [Lib.Grid] = Lib.$fEqGrid
instance GHC.Classes.Eq [Lib.Line] = Lib.$fEqLine
instance GHC.Classes.Eq [Lib.Nucleobase] = Lib.$fEqNucleobase
instance GHC.Classes.Eq [Lib.Nucleotide] = Lib.$fEqNucleotide
instance Data.Foldable.Foldable [Lib.Grid] = Lib.$fFoldableGrid
instance Data.Foldable.Foldable [Lib.Line] = Lib.$fFoldableLine
instance GHC.Base.Functor [Lib.Grid] = Lib.$fFunctorGrid
instance GHC.Base.Functor [Lib.Line] = Lib.$fFunctorLine
instance Lib.M2M [GHC.Base.Maybe, []] = Lib.$fM2MMaybe[]
instance GHC.Classes.Ord [Lib.Direction] = Lib.$fOrdDirection
instance GHC.Classes.Ord [Lib.Grid] = Lib.$fOrdGrid
instance GHC.Show.Show [Lib.Cell] = Lib.$fShowCell
instance GHC.Show.Show [Lib.Direction] = Lib.$fShowDirection
instance GHC.Show.Show [Lib.Grid] = Lib.$fShowGrid
instance GHC.Show.Show [Lib.Line] = Lib.$fShowLine
instance GHC.Show.Show [Lib.Nucleobase] = Lib.$fShowNucleobase
instance GHC.Show.Show [Lib.Nucleotide] = Lib.$fShowNucleotide
instance Data.Traversable.Traversable [Lib.Grid]
  = Lib.$fTraversableGrid
instance Data.Traversable.Traversable [Lib.Line]
  = Lib.$fTraversableLine
"SPEC $ccompare @ Direction @ Nucleotide" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                     Lib.Nucleotide)
                                                          ($dOrd :: GHC.Classes.Ord Lib.Direction)
  Lib.$fOrdGrid_$ccompare @ Lib.Direction @ Lib.Nucleotide $dOrd $dEq
  = Lib.$fOrdGrid_$s$ccompare
"SPEC biggersnd @ Int _" [ALWAYS] forall @ a
                                         ($dOrd :: GHC.Classes.Ord GHC.Types.Int)
  Lib.biggersnd @ GHC.Types.Int @ a $dOrd
  = Lib.biggersnd_$sbiggersnd @ a
"SPEC neuConfs @ (Maybe (Nucleotide, Direction))" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                             (GHC.Base.Maybe
                                                                                (Lib.Nucleotide,
                                                                                 Lib.Direction)))
  Lib.neuConfs @ (GHC.Base.Maybe (Lib.Nucleotide, Lib.Direction))
               $dEq
  = Lib.neuConfs_$sneuConfs
"SPEC/Lib $fEq(,) @ Nucleotide @ Direction" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                        Lib.Direction)
                                                            ($dEq :: GHC.Classes.Eq Lib.Nucleotide)
  GHC.Classes.$fEq(,) @ Lib.Nucleotide @ Lib.Direction $dEq $dEq1
  = Lib.$fEqGrid_$s$fEq(,)
"SPEC/Lib $fEqMaybe @ (Nucleotide, Direction)" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                          (Lib.Nucleotide,
                                                                           Lib.Direction))
  GHC.Base.$fEqMaybe @ (Lib.Nucleotide, Lib.Direction) $dEq
  = Lib.$fEqGrid_$s$fEqMaybe
"SPEC/Lib $fEqMaybe_$c== @ (Nucleotide, Direction)" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                               (Lib.Nucleotide,
                                                                                Lib.Direction))
  GHC.Base.$fEqMaybe_$c== @ (Lib.Nucleotide, Lib.Direction) $dEq
  = Lib.$fEqGrid_$s$fEqMaybe_$c==
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

